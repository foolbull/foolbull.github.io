<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.1.0">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=7.1.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true,"dimmer":true,"b2t":true,"scrollpercent":true},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="理想国">
<meta property="og:url" content="/page/3/index.html">
<meta property="og:site_name" content="理想国">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理想国">





  
  
  <link rel="canonical" href="/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>理想国</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">理想国</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">我要看尽这世间繁华</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/08/27/post/apitestengine-supersede-locust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/27/post/apitestengine-supersede-locust/" class="post-title-link" itemprop="url">ApiTestEngine 集成 Locust 实现更好的性能测试体验</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-27T00:00:00+08:00">2017-08-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>不是接口测试框架么，也能实现性能测试？</p>
<p>是的，你没有看错，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>集成了<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>性能测试框架，只需一份测试用例，就能同时实现接口自动化测试和接口性能测试，在不改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>任何特性的情况下，甚至比<code>Locust</code>本身更易用。</p>
<p>如果你还没有接触过<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>这款性能测试工具，那么这篇文章可能不适合你。但我还是强烈推荐你了解一下这款工具。简单地说，<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>是一款采用<code>Python</code>语言编写实现的开源性能测试工具，简洁、轻量、高效，并发机制基于<code>gevent</code>协程，可以实现单机模拟生成较高的并发压力。关于<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的特性介绍和使用教程，我之前已经写过不少，你们可以在我的博客中找到<a href="https://debugtalk.com/tags/Locust/" target="_blank" rel="noopener">对应文章</a>。</p>
<p>如果你对实现的过程没有兴趣，可以直接跳转到文章底部，看<code>最终实现效果</code>章节。</p>
<h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>在当前市面上的测试工具中，接口测试和性能测试基本上是两个泾渭分明的领域。这也意味着，针对同一个系统的服务端接口，我们要对其实现接口自动化测试和接口性能测试时，通常都是采用不同的工具，分别维护两份测试脚本或用例。</p>
<p>之前我也是这么做的。但是在做了一段时间后我就在想，不管是接口功能测试，还是接口性能测试，核心都是要模拟对接口发起请求，然后对接口响应内容进行解析和校验；唯一的差异在于，接口性能测试存在并发的概念，相当于模拟了大量用户同时在做接口测试。</p>
<p>既然如此，那接口自动化测试用例和接口性能测试脚本理应可以合并为一套，这样就可以避免重复的脚本开发工作了。</p>
<p>在开发<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>的过程中，之前的文章也说过，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>完全基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Python-Requests</code></a>库实现HTTP的请求处理，可以在编写接口测试用例时复用到<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Python-Requests</code></a>的所有功能特性。而之前在学习<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的源码时，发现<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>在实现HTTP请求的时候，也完全是基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Python-Requests</code></a>库。</p>
<p>在这一层关系的基础上，我提出一个大胆的设想，能否通过一些方式或手段，可以使<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>中编写的<code>YAML/JSON</code>格式的接口测试用例，也能直接让<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>直接调用呢？</p>
<h2 id="灵感初探"><a href="#灵感初探" class="headerlink" title="灵感初探"></a>灵感初探</h2><p>想法有了以后，就开始探索实现的方法了。</p>
<p>首先，我们可以看下<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的脚本形式。如下例子是一个比较简单的场景（截取自官网首页）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteTasks</span><span class="params">(TaskSet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.post(<span class="string">"/login"</span>, &#123;</span><br><span class="line">            <span class="string">"username"</span>: <span class="string">"test_user"</span>,</span><br><span class="line">            <span class="string">"password"</span>: <span class="string">""</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.get(<span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.get(<span class="string">"/about/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span><span class="params">(HttpLocust)</span>:</span></span><br><span class="line">    task_set = WebsiteTasks</span><br><span class="line">    min_wait = <span class="number">5000</span></span><br><span class="line">    max_wait = <span class="number">15000</span></span><br></pre></td></tr></table></figure>
<p>在<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的脚本中，我们会在<code>TaskSet</code>子类中描述单个用户的行为，每一个带有<code>@task</code>装饰器的方法都对应着一个HTTP请求场景。而<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的一个很大特点就是，所有的测试用例脚本都是<code>Python</code>文件，因此我们可以采用Python实现各种复杂的场景。</p>
<p>等等！模拟单个用户请求，而且还是纯粹的Python语言，我们不是在接口测试中已经实现的功能么？</p>
<p>例如，下面的代码就是从单元测试中截取的测试用例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run_testset</span><span class="params">(self)</span>:</span></span><br><span class="line">    testcase_file_path = os.path.join(</span><br><span class="line">        os.getcwd(), <span class="string">'examples/quickstart-demo-rev-3.yml'</span>)</span><br><span class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</span><br><span class="line">    results = self.test_runner.run_testset(testsets[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><code>test_runner.run_testset</code>是已经在<code>ApiTestEngine</code>中实现的方法，作用是传入测试用例（<code>YAML/JSON</code>）的路径，然后就可以加载测试用例，运行整个测试场景。并且，由于我们在测试用例<code>YAML/JSON</code>中已经描述了<code>validators</code>，即接口的校验部分，因此我们也无需再对接口响应结果进行校验描述了。</p>
<p>接下来，实现方式就非常简单了。</p>
<p>我们只需要制作一个<code>locustfile.py</code>的模板文件，内容如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> zmq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</span><br><span class="line"><span class="keyword">from</span> ate <span class="keyword">import</span> utils, runner</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageTasks</span><span class="params">(TaskSet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.test_runner = runner.Runner(self.client)</span><br><span class="line">        self.testset = self.locust.testset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_specified_scenario</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.test_runner.run_testset(self.testset)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageUser</span><span class="params">(HttpLocust)</span>:</span></span><br><span class="line">    host = <span class="string">''</span></span><br><span class="line">    task_set = WebPageTasks</span><br><span class="line">    min_wait = <span class="number">1000</span></span><br><span class="line">    max_wait = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">    testcase_file_path = os.path.join(os.getcwd(), <span class="string">'skypixel.yml'</span>)</span><br><span class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</span><br><span class="line">    testset = testsets[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>可以看出，整个文件中，只有测试用例文件的路径是与具体测试场景相关的，其它内容全都可以不变。</p>
<p>于是，针对不同的测试场景，我们只需要将<code>testcase_file_path</code>替换为接口测试用例文件的路径，即可实现对应场景的接口性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ApiTestEngine git:(master) ✗ locust -f locustfile.py</span><br><span class="line">[2017-08-27 11:30:01,829] bogon/INFO/locust.main: Starting web monitor at *:8089</span><br><span class="line">[2017-08-27 11:30:01,831] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br></pre></td></tr></table></figure>
<p>后面的操作就完全是<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的内容了，使用方式完全一样。</p>
<p><img src="/images/locust-start.jpg" alt></p>
<h2 id="优化1：自动生成locustfile"><a href="#优化1：自动生成locustfile" class="headerlink" title="优化1：自动生成locustfile"></a>优化1：自动生成locustfile</h2><p>通过前面的探索实践，我们基本上就实现了一份测试用例同时兼具接口自动化测试和接口性能测试的功能。</p>
<p>然而，在使用上还不够便捷，主要有两点：</p>
<ul>
<li>需要手工修改模板文件中的<code>testcase_file_path</code>路径；</li>
<li><code>locustfile.py</code>模板文件的路径必须放在<code>ApiTestEngine</code>的项目根目录下。</li>
</ul>
<p>于是，我产生了让<code>ApiTestEngine</code>框架本身自动生成<code>locustfile.py</code>文件的想法。</p>
<p>在实现这个想法的过程中，我想过两种方式。</p>
<p>第一种，通过分析<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的源码，可以看到<code>Locust</code>在<code>main.py</code>中具有一个<code>load_locustfile</code>方法，可以加载Python格式的文件，并提取出其中的<code>locust_classes</code>（也就是<code>Locust</code>的子类）；后续，就是将<code>locust_classes</code>作为参数传给<code>Locust</code>的<code>Runner</code>了。</p>
<p>若采用这种思路，我们就可以实现一个类似<code>load_locustfile</code>的方法，将<code>YAML/JSON</code>文件中的内容动态生成<code>locust_classes</code>，然后再传给<code>Locust</code>的<code>Runner</code>。这里面会涉及到动态地创建类和添加方法，好处是不需要生成<code>locustfile.py</code>中间文件，并且可以实现最大的灵活性，但缺点在于需要改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的源码，即重新实现<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的<code>main.py</code>中的多个函数。虽然难度不会太大，但考虑到后续需要与<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的更新保持一致，具有一定的维护工作量，便放弃了该种方案。</p>
<p>第二种，就是生成<code>locustfile.py</code>这样一个中间文件，然后将文件路径传给<code>Locust</code>。这样的好处在于我们可以不改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的任何地方，直接对其进行使用。与<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的传统使用方式差异在于，之前我们是在<code>Terminal</code>中通过参数启动<code>Locust</code>，而现在我们是在<code>ApiTestEngine</code>框架中通过Python代码启动<code>Locust</code>。</p>
<p>具体地，我在<code>setup.py</code>的<code>entry_points</code>中新增了一个命令<code>locusts</code>，并绑定了对应的程序入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">    <span class="string">'console_scripts'</span>: [</span><br><span class="line">        <span class="string">'ate=ate.cli:main_ate'</span>,</span><br><span class="line">        <span class="string">'locusts=ate.cli:main_locust'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ate/cli.py</code>中新增了<code>main_locust</code>函数，作为<code>locusts</code>命令的入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Performance test with locust: parse command line options and run commands.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> locust.main <span class="keyword">import</span> main</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        print(<span class="string">"Locust is not installed, exit."</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    sys.argv[<span class="number">0</span>] = <span class="string">'locust'</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        sys.argv.extend([<span class="string">"-h"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">"-h"</span>, <span class="string">"--help"</span>, <span class="string">"-V"</span>, <span class="string">"--version"</span>]:</span><br><span class="line">        main()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        testcase_index = sys.argv.index(<span class="string">'-f'</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> testcase_index &lt; len(sys.argv)</span><br><span class="line">    <span class="keyword">except</span> (ValueError, AssertionError):</span><br><span class="line">        print(<span class="string">"Testcase file is not specified, exit."</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    testcase_file_path = sys.argv[testcase_index]</span><br><span class="line">    sys.argv[testcase_index] = parse_locustfile(testcase_file_path)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>若你执行<code>locusts -V</code>或<code>locusts -h</code>，会发现效果与<code>locust</code>的特性完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -V</span><br><span class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout: Locust 0.8a2</span><br><span class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout:</span><br></pre></td></tr></table></figure>
<p>事实上，通过上面的代码（<code>main_locust</code>）也可以看出，<code>locusts</code>命令只是对<code>locust</code>进行了一层封装，用法基本等价。唯一的差异在于，当<code>-f</code>参数指定的是<code>YAML/JSON</code>格式的用例文件时，会先转换为Python格式的<code>locustfile.py</code>，然后再传给<code>locust</code>。</p>
<p>至于解析函数<code>parse_locustfile</code>，实现起来也很简单。我们只需要在框架中保存一份<code>locustfile.py</code>的模板文件（<code>ate/locustfile_template</code>），并将<code>testcase_file_path</code>采用占位符代替。然后，在解析函数中，就可以读取整个模板文件，将其中的占位符替换为<code>YAML/JSON</code>用例文件的实际路径，然后再保存为<code>locustfile.py</code>，并返回其路径即可。</p>
<p>具体的代码就不贴了，有兴趣的话可自行查看。</p>
<p>通过这一轮优化，<code>ApiTestEngine</code>就继承了<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的全部功能，并且可以直接指定<code>YAML/JSON</code>格式的文件启动<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>执行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -f examples/first-testcase.yml</span><br><span class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</span><br><span class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</span><br></pre></td></tr></table></figure>
<h2 id="优化2：一键启动多个locust实例"><a href="#优化2：一键启动多个locust实例" class="headerlink" title="优化2：一键启动多个locust实例"></a>优化2：一键启动多个locust实例</h2><p>经过第一轮优化后，本来应该是告一段落了，因为此时<code>ApiTestEngine</code>已经可以非常便捷地实现接口自动化测试和接口性能测试的切换了。</p>
<p>直到有一天，在<code>TesterHome</code>论坛讨论<code>Locust</code>的一个<a href="https://testerhome.com/topics/9277#reply-84542" target="_blank" rel="noopener">回复</a>中，<a href="https://testerhome.com/keithmork" target="_blank" rel="noopener"><code>@keithmork</code></a>说了这么一句话。</p>
<blockquote>
<p>期待有一天<code>ApiTestEngine</code>的热度超过<code>Locust</code>本身</p>
</blockquote>
<p>看到这句话时我真的不禁泪流满面。虽然我也是一直在用心维护<code>ApiTestEngine</code>，却从未有过这样的奢望。</p>
<p>但反过来细想，为啥不能有这样的想法呢？当前<code>ApiTestEngine</code>已经继承了<code>Locust</code>的所有功能，在不影响<code>Locust</code>已有特性的同时，还可以采用<code>YAML/JSON</code>格式来编写维护测试用例，并实现了一份测试用例可同时用于接口自动化和接口性能测试的目的。</p>
<p>这些特性都是<code>Locust</code>所不曾拥有的，而对于使用者来说的确也都是比较实用的功能。</p>
<p>于是，新的目标在内心深处萌芽了，那就是在<code>ApiTestEngine</code>中通过对<code>Locust</code>更好的封装，让<code>Locust</code>的使用者体验更爽。</p>
<p>然后，我又想到了自己之前做的一个开源项目，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="noopener"><code>debugtalk/stormer</code></a>。当时做这个项目的初衷在于，当我们使用<code>Locust</code>进行压测时，要想使用压测机所有CPU的性能，就需要采用<code>master-slave</code>模式。因为<code>Locust</code>默认是单进程运行的，只能运行在压测机的一个CPU核上；而通过采用<code>master-slave</code>模式，启动多个<code>slave</code>，就可以让不同的<code>slave</code>运行在不同的CPU核上，从而充分发挥压测机多核处理器的性能。</p>
<p>而在实际使用<code>Locust</code>的时候，每次只能手动启动<code>master</code>，并依次手动启动多个<code>slave</code>。若遇到测试脚本调整的情况，就需要逐一结束<code>Locust</code>的所有进程，然后再重复之前的启动步骤。如果有使用过<code>Locust</code>的同学，应该对此痛苦的经历都有比较深的体会。当时也是基于这一痛点，我开发了<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="noopener"><code>debugtalk/stormer</code></a>，目的就是可以一次性启动或销毁多个<code>Locust</code>实例。这个脚本做出来后，自己用得甚爽，也得到了<code>Github</code>上一些朋友的青睐。</p>
<p>既然现在要提升<code>ApiTestEngine</code>针对<code>Locust</code>的使用便捷性，那么这个特性毫无疑问也应该加进去。就此，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="noopener"><code>debugtalk/stormer</code></a>项目便被废弃，正式合并到<code>debugtalk/ApiTestEngine</code>。</p>
<p>想法明确后，实现起来也挺简单的。</p>
<p>原则还是保持不变，那就是不改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>本身的特性，只在传参的时候在中间层进行操作。</p>
<p>具体地，我们可以新增一个<code>--full-speed</code>参数。当不指定该参数时，使用方式跟之前完全相同；而指定<code>--full-speed</code>参数后，就可以采用多进程的方式启动多个实例（实例个数等于压测机的处理器核数）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># do original work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"--full-speed"</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        locusts.run_locusts_at_full_speed(sys.argv)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        locusts.main()</span><br></pre></td></tr></table></figure>
<p>具体实现逻辑在<code>ate/locusts.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> locust.main <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_master</span><span class="params">(sys_argv)</span>:</span></span><br><span class="line">    sys_argv.append(<span class="string">"--master"</span>)</span><br><span class="line">    sys.argv = sys_argv</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_slave</span><span class="params">(sys_argv)</span>:</span></span><br><span class="line">    sys_argv.extend([<span class="string">"--slave"</span>])</span><br><span class="line">    sys.argv = sys_argv</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_locusts_at_full_speed</span><span class="params">(sys_argv)</span>:</span></span><br><span class="line">    sys_argv.pop(sys_argv.index(<span class="string">"--full-speed"</span>))</span><br><span class="line">    slaves_num = multiprocessing.cpu_count()</span><br><span class="line"></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(slaves_num):</span><br><span class="line">        p_slave = multiprocessing.Process(target=start_slave, args=(sys_argv,))</span><br><span class="line">        p_slave.daemon = <span class="literal">True</span></span><br><span class="line">        p_slave.start()</span><br><span class="line">        processes.append(p_slave)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_master(sys_argv)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>由此可见，关键点也就是使用了<code>multiprocessing.Process</code>，在不同的进程中分别调用<code>Locust</code>的<code>main()</code>函数，实现逻辑十分简单。</p>
<h2 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h2><p>经过前面的优化，采用<code>ApiTestEngine</code>执行性能测试时，使用就十分便捷了。</p>
<p>安装<code>ApiTestEngine</code>后，系统中就具有了<code>locusts</code>命令，使用方式跟<code>Locust</code>框架的<code>locust</code>几乎完全相同，我们完全可以使用<code>locusts</code>命令代替原生的<code>locust</code>命令。</p>
<p>例如，下面的命令执行效果与<code>locust</code>完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -V</span><br><span class="line">$ locusts -h</span><br><span class="line">$ locusts -f locustfile.py</span><br><span class="line">$ locusts -f locustfile.py --master -P 8088</span><br><span class="line">$ locusts -f locustfile.py --slave &amp;</span><br></pre></td></tr></table></figure>
<p>差异在于，<code>locusts</code>具有更加丰富的功能。</p>
<p>在<code>ApiTestEngine</code>中编写的<code>YAML/JSON</code>格式的接口测试用例文件，直接运行就可以启动<code>Locust</code>运行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -f examples/first-testcase.yml</span><br><span class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</span><br><span class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</span><br></pre></td></tr></table></figure>
<p>加上<code>--full-speed</code>参数，就可以同时启动多个<code>Locust</code>实例（实例个数等于处理器核数），充分发挥压测机多核处理器的性能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -f examples/first-testcase.yml --full-speed -P 8088</span><br><span class="line">[2017-08-26 23:51:47,071] bogon/INFO/locust.main: Starting web monitor at *:8088</span><br><span class="line">[2017-08-26 23:51:47,075] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,078] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,080] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,083] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.runners: Client <span class="string">'bogon_656e0af8e968a8533d379dd252422ad3'</span> reported as ready. Currently 1 clients ready to swarm.</span><br><span class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_09f73850252ee4ec739ed77d3c4c6dba'</span> reported as ready. Currently 2 clients ready to swarm.</span><br><span class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_869f7ed671b1a9952b56610f01e2006f'</span> reported as ready. Currently 3 clients ready to swarm.</span><br><span class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_80a804cda36b80fac17b57fd2d5e7cdb'</span> reported as ready. Currently 4 clients ready to swarm.</span><br></pre></td></tr></table></figure>
<p><img src="/images/locusts-full-speed.jpg" alt></p>
<p>后续，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>将持续进行优化，欢迎大家多多反馈改进建议。</p>
<p>Enjoy!</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/08/20/post/apitestengine-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/20/post/apitestengine-quickstart/" class="post-title-link" itemprop="url">ApiTestEngine QuickStart</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-20T00:00:00+08:00">2017-08-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Introduction-to-Sample-Interface-Service"><a href="#Introduction-to-Sample-Interface-Service" class="headerlink" title="Introduction to Sample Interface Service"></a>Introduction to Sample Interface Service</h2><p>Along with this project, I devised a sample interface service, and you can use it to familiarize how to play with <code>ApiTestEngine</code>.</p>
<p>This sample service mainly has two parts:</p>
<ul>
<li>Authorization, each request of other APIs should sign with some header fields and get token first.</li>
<li>RESTful APIs for user management, you can do CRUD manipulation on users.</li>
</ul>
<p>As you see, it is very similar to the mainstream production systems. Therefore once you are familiar with handling this demo service, you can master most test scenarios in your project.</p>
<h2 id="Launch-Sample-Interface-Service"><a href="#Launch-Sample-Interface-Service" class="headerlink" title="Launch Sample Interface Service"></a>Launch Sample Interface Service</h2><p>The demo service is a flask server, we can launch it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export FLASK_APP=tests/api_server.py</span><br><span class="line">$ flask run</span><br><span class="line"> * Serving Flask app &quot;tests.api_server&quot;</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>
<p>Now the sample interface service is running, and we can move on to the next step.</p>
<h2 id="Capture-HTTP-request-and-response"><a href="#Capture-HTTP-request-and-response" class="headerlink" title="Capture HTTP request and response"></a>Capture HTTP request and response</h2><p>Before we write testcases, we should know the details of the API. It is a good choice to use a web debugging proxy tool like <code>Charles Proxy</code> to capture the HTTP traffic.</p>
<p>For example, the image below illustrates getting token from the sample service first, and then creating one user successfully.</p>
<p><img src="/images/ate-quickstart-http-1.jpg" alt></p>
<p><img src="/images/ate-quickstart-http-2.jpg" alt></p>
<p>After thorough understanding of the APIs, we can now begin to write testcases.</p>
<h2 id="Write-the-first-test-case"><a href="#Write-the-first-test-case" class="headerlink" title="Write the first test case"></a>Write the first test case</h2><p>Open your favorite text editor and you can write test cases like this.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">iOS/10.3</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">ios</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="number">19067</span><span class="string">cf712265eb5426db8d3664026c1ccea02b9</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">F8prvGryC5beBr4g</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>As you see, each API request is described in a <code>test</code> block. And in the <code>request</code> field, it describes the detail of HTTP request, includes url, method, headers and data, which are in line with the captured traffic.</p>
<p>You may wonder why we use the <code>json</code> field other than <code>data</code>. That’s because the post data is in <code>JSON</code> format, when we use <code>json</code> to indicate the post data, we do not have to specify <code>Content-Type</code> to be <code>application/json</code> in request headers or dump data before request.</p>
<p>Have you recalled some familiar scenes?</p>
<p>Yes! That’s what we did in <a href="requests.request"><code>requests.request</code></a>! Since <code>ApiTestEngine</code> takes full reuse of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>, it inherits all powerful features of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>, and we can handle HTTP request as the way we do before.</p>
<h2 id="Run-test-cases"><a href="#Run-test-cases" class="headerlink" title="Run test cases"></a>Run test cases</h2><p>Suppose the test case file is named as <code>quickstart-demo-rev-0.yml</code> and is located in <code>examples</code> folder, then we can run it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ate examples/demo-rev-0.yml</span><br><span class="line">Running tests...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</span><br><span class="line">INFO:root: status_code: 200, response_time: 48 ms, response_length: 46 bytes</span><br><span class="line">OK (0.049669)s</span><br><span class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</span><br><span class="line">ERROR:root: Failed to POST http://127.0.0.1:5000/api/users/1000! exception msg: 403 Client Error: FORBIDDEN for url: http://127.0.0.1:5000/api/users/1000</span><br><span class="line">ERROR (0.006471)s</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.056s</span><br><span class="line"></span><br><span class="line">FAILED</span><br><span class="line"> (Errors=1)</span><br></pre></td></tr></table></figure>
<p>Oops! The second test case failed with 403 status code.</p>
<p>That is because we request with the same data as we captured in <code>Charles Proxy</code>, while the <code>token</code> is generated dynamically, thus the recorded data can not be be used twice directly.</p>
<h2 id="Optimize-test-case-correlation"><a href="#Optimize-test-case-correlation" class="headerlink" title="Optimize test case: correlation"></a>Optimize test case: correlation</h2><p>To fix this problem, we should correlate <code>token</code> field in the second API test case, which is also called <code>correlation</code>.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">iOS/10.3</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">ios</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="number">19067</span><span class="string">cf712265eb5426db8d3664026c1ccea02b9</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">$token</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>As you see, the <code>token</code> field is no longer hardcoded, instead it is extracted from the first API request with <code>extractors</code> mechanism. In the meanwhile, it is assigned to <code>token</code> variable, which can be referenced by the subsequent API requests.</p>
<p>Now we save the test cases to <code>quickstart-demo-rev-1.yml</code> and rerun it, and we will find that both API requests to be successful.</p>
<h2 id="Optimize-test-case-parameterization"><a href="#Optimize-test-case-parameterization" class="headerlink" title="Optimize test case: parameterization"></a>Optimize test case: parameterization</h2><p>Let’s look back to our test set <code>quickstart-demo-rev-1.yml</code>, and we can see the <code>device_sn</code> field is still hardcoded. This may be quite different from the actual scenarios.</p>
<p>In actual scenarios, each user’s <code>device_sn</code> is different, so we should parameterize the request parameters, which is also called <code>parameterization</code>. In the meanwhile, the <code>sign</code> field is calculated with other header fields, thus it may change significantly if any header field changes slightly.</p>
<p>However, the test cases are only <code>YAML</code> documents, it is impossible to generate parameters dynamically in such text. Fortunately, we can combine <code>Python</code> scripts with <code>YAML</code> test cases in <code>ApiTestEngine</code>.</p>
<p>To achieve this goal, we can utilize <code>import_module_functions</code> and <code>variables</code> mechanisms.</p>
<p>To be specific, we can create a Python file (<code>examples/utils.py</code>) and implement the related algorithm in it. Since we want to import this file, so we should put a <code>__init__.py</code> in this folder to make it as a Python module.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">SECRET_KEY = <span class="string">"DebugTalk"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sign</span><span class="params">(*args)</span>:</span></span><br><span class="line">    content = <span class="string">''</span>.join(args).encode(<span class="string">'ascii'</span>)</span><br><span class="line">    sign_key = SECRET_KEY.encode(<span class="string">'ascii'</span>)</span><br><span class="line">    sign = hmac.new(sign_key, content, hashlib.sha1).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> sign</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></span><br><span class="line">    random_char_list = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len):</span><br><span class="line">        random_char = random.choice(string.ascii_letters + string.digits)</span><br><span class="line">        random_char_list.append(random_char)</span><br><span class="line"></span><br><span class="line">    random_string = <span class="string">''</span>.join(random_char_list)</span><br><span class="line">    <span class="keyword">return</span> random_string</span><br></pre></td></tr></table></figure>
<p>And then, we can revise our demo test case and reference the functions. Suppose the revised file named <code>quickstart-demo-rev-2.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    import_module_functions:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">examples.utils</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></span><br><span class="line"><span class="attr">        - device_sn:</span> <span class="string">$&#123;gen_random_string(15)&#125;</span></span><br><span class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></span><br><span class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">$user_agent</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="string">$device_sn</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">$os_platform</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="string">$app_version</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="string">$&#123;get_sign($user_agent,</span> <span class="string">$device_sn,</span> <span class="string">$os_platform,</span> <span class="string">$app_version)&#125;</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="string">$device_sn</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">$token</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>In this revised test case, we firstly import module functions in <code>import_module_functions</code> block by specifying the Python module path, which is relative to the current working directory.</p>
<p>To make fields like <code>device_sn</code> can be used more than once, we also bind values to variables in <code>variables</code> block. When we bind variables, we can not only bind exact value to a variable name, but also can call a function and bind the evaluated value to it.</p>
<p>When we want to reference a variable in the test case, we can do this with a escape character <code>$</code>. For example, <code>$user_agent</code> will not be taken as a normal string, and <code>ApiTestEngine</code> will consider it as a variable named <code>user_agent</code>, search and return its binding value.</p>
<p>When we want to reference a function, we shall use another escape character <code>${}</code>. Any content in <code>${}</code> will be considered as function calling, so we should guarantee that we call functions in the right way. At the same time, variables can also be referenced as parameters of function.</p>
<h2 id="Optimize-test-case-overall-config-block"><a href="#Optimize-test-case-overall-config-block" class="headerlink" title="Optimize test case: overall config block"></a>Optimize test case: overall config block</h2><p>There is still one issue unsolved.</p>
<p>The <code>device_sn</code> field is defined in the first API test case, thus it may be impossible to reference it in other test cases. Context separation is a well-designed mechanism, and we should obey this good practice.</p>
<p>To handle this case, overall <code>config</code> block is supported in <code>ApiTestEngine</code>. If we define variables or import functions in <code>config</code> block, these variables and functions will become global and can be referenced in the whole test set.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># examples/quickstart-demo-rev-3.yml</span></span><br><span class="line"><span class="attr">- config:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"smoketest for CRUD users."</span></span><br><span class="line"><span class="attr">    import_module_functions:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">examples.utils</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - device_sn:</span> <span class="string">$&#123;gen_random_string(15)&#125;</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        base_url:</span> <span class="attr">http://127.0.0.1:5000</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="string">$device_sn</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></span><br><span class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></span><br><span class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">$user_agent</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">$os_platform</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="string">$app_version</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="string">$&#123;get_sign($user_agent,</span> <span class="string">$device_sn,</span> <span class="string">$os_platform,</span> <span class="string">$app_version)&#125;</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">$token</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>As you see, we import public <code>Python</code> modules and variables in <code>config</code> block. Also, we can set <code>base_url</code> in <code>config</code> block, thereby we can only specify relative path in each API request url. Besides, we can also set common fields in <code>config</code> <code>request</code>, such as <code>device_sn</code> in headers.</p>
<p>Until now, the test cases are finished and each detail is handled properly.</p>
<h2 id="Run-test-cases-and-generate-report"><a href="#Run-test-cases-and-generate-report" class="headerlink" title="Run test cases and generate report"></a>Run test cases and generate report</h2><p>Finally, let’s run test set <code>quickstart-demo-rev-4.yml</code> once more.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ate examples/quickstart-demo-rev-4.yml</span><br><span class="line">Running tests...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</span><br><span class="line">INFO:root: status_code: 200, response_time: 33 ms, response_length: 46 bytes</span><br><span class="line">OK (0.037027)s</span><br><span class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</span><br><span class="line">INFO:root: status_code: 201, response_time: 15 ms, response_length: 54 bytes</span><br><span class="line">OK (0.016414)s</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.054s</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">Generating HTML reports...</span><br><span class="line">Template is not specified, load default template instead.</span><br><span class="line">Reports generated: /Users/Leo/MyProjects/ApiTestEngine/reports/quickstart-demo-rev-0/2017-08-01-16-51-51.html</span><br></pre></td></tr></table></figure>
<p>Great! The test case runs successfully and generates a <code>HTML</code> test report.</p>
<p><img src="/images/ate-quickstart-demo-report.jpg" alt></p>
<h2 id="Further-more"><a href="#Further-more" class="headerlink" title="Further more"></a>Further more</h2><p>This is just a starting point, see the <code>advanced guide</code> for the advanced features.</p>
<ul>
<li>templating</li>
<li>data extraction and validation</li>
<li><a href="https://github.com/debugtalk/ApiTestEngine/blob/master/docs/comparator.md" target="_blank" rel="noopener"><code>comparator</code></a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/08/05/post/How-to-install-a-package-from-Github-that-has-other-github-dependencies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/05/post/How-to-install-a-package-from-Github-that-has-other-github-dependencies/" class="post-title-link" itemprop="url">How to install a package from Github that has other github dependencies ?</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-05 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-05T00:00:00+08:00">2017-08-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在开发<code>ApiTestEngine</code>时遇到一个安装包依赖的问题，耗费了不少时间寻找解决方案，考虑到还算比较有普遍性，因此总结形成这篇文章。</p>
<h2 id="从-pip-install-说起"><a href="#从-pip-install-说起" class="headerlink" title="从 pip install 说起"></a>从 pip install 说起</h2><p>先不那么简单地描述下背景。</p>
<p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>作为一款接口测试工具，需要具有灵活的命令行调用方式，因此最好能在系统中进行安装并注册为一个<code>CLI</code>命令。</p>
<p>在Python中，安装依赖库的最佳方式是采用<a href="https://pip.pypa.io/en/stable/" target="_blank" rel="noopener"><code>pip</code></a>，例如安装<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>时，就可以采用如下命令搞定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pip install locustio</span><br><span class="line">Collecting locustio</span><br><span class="line">  Using cached locustio-0.7.5.tar.gz</span><br><span class="line">[...]</span><br><span class="line">Successfully installed locustio-0.7.5</span><br></pre></td></tr></table></figure>
<p>但要想采用<code>pip install SomePackage</code>的方式，前提是<code>SomePackage</code>已经托管在<code>PyPI</code>。关于<code>PyPI</code>，可以理解为<code>Python</code>语言的第三方库的仓库索引，当前绝大多数流行的<code>Python</code>第三方库都托管在<code>PyPI</code>上。</p>
<p>但是，这里存在一个问题。在<code>PyPI</code>当中，所有的包都是由其作者自行上传的。如果作者比较懒，那么可能托管在<code>PyPI</code>上的最新版本相较于最新代码就会比较滞后。</p>
<p><code>Locust</code>就是一个典型的例子。从上面的安装过程可以看出，我们采用<code>pip install locustio</code>安装的<code>Locust</code>版本是<code>v0.7.5</code>，而在<code>Locust</code>的<code>Github</code>仓库中，<code>v0.7.5</code>已经是一年之前的版本了。也是因为这个原因，之前在我的博客里面介绍<code>Locust</code>的<a href="https://debugtalk.com/post/head-first-locust-user-guide/" target="_blank" rel="noopener">图表展示功能</a>后，已经有不下5个人向我咨询为啥他们看不到这个图表模块。这是因为<code>Locust</code>的图表模块是在今年（2017）年初时添加的功能，master分支的代码版本也已经升级到<code>v0.8a2</code>了，但<code>PyPI</code>上的版本却一直没有更新。</p>
<p>而要想使用到项目最新的功能，就只能采用源码进行安装。</p>
<p>大多数编程语言在使用源码进行安装时，都需要先将源码下载到本地，然后通过命令进行编译，例如<code>Linux</code>中常见的<code>make &amp;&amp; make install</code>。对于<code>Python</code>项目来说，也可以采用类似的模式，先将项目<code>clone</code>到本地，然后进入到项目的根目录，执行<code>python setup.py install</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/locustio/locust.git</span><br><span class="line">$ cd locust</span><br><span class="line">$ python setup.py install</span><br><span class="line">[...]</span><br><span class="line">Finished processing dependencies for locustio==0.8a2</span><br></pre></td></tr></table></figure>
<p>不过，要想采用这种方式进行安装也是有前提的，那就是项目必须已经实现了基于<code>setuptools</code>的安装方式，并在项目的根目录下存在<code>setup.py</code>。</p>
<p>可以看出，这种安装方式还是比较繁琐的，需要好几步才能完成安装。而且，对于大多数使用者来说，他们并不需要阅读项目源码，因此<code>clone</code>操作也实属多余。</p>
<p>可喜的是，<code>pip</code>不仅支持安装<code>PyPI</code>上的包，也可以直接通过项目的<code>git</code>地址进行安装。还是以<code>Locust</code>项目为例，我们通过<code>pip</code>命令也可以实现一条命令安装<code>Github</code>项目源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pip install git+https://github.com/locustio/locust.git@master#egg=locustio</span><br><span class="line">Collecting locustio from git+https://github.com/locustio/locust.git@master#egg=locustio</span><br><span class="line">[...]</span><br><span class="line">Successfully installed locustio-0.8a2</span><br></pre></td></tr></table></figure>
<p>对于项目地址来说，完整的描述应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install vcs+protocol://repo_url/#egg=pkg&amp;subdirectory=pkg_dir</span><br></pre></td></tr></table></figure>
<p>这里的<code>vcs</code>也不仅限于<code>git</code>，<code>svn</code>和<code>hg</code>也是一样的，而<code>protocol</code>除了采用<code>SSH</code>形式的项目地址，也可以采用<code>HTTPS</code>的地址，在此不再展开。</p>
<p>通过这种方式，我们就总是可以使用到项目的最新功能特性了。当然，前提条件也是一样的，需要项目中已经实现了<code>setup.py</code>。</p>
<p>考虑到<code>ApiTestEngine</code>还处于频繁的新特性开发阶段，因此这种途径无疑是让用户安装使用最新代码的最佳方式。</p>
<h2 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h2><p>在<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>中，存在测试结果报告展示这一部分的功能，而这部分的功能是需要依赖于另外一个托管在GitHub上的项目，<a href="https://github.com/debugtalk/PyUnitReport" target="_blank" rel="noopener"><code>PyUnitReport</code></a>。</p>
<p>于是，问题就变为：如何构造<code>ApiTestEngine</code>项目的<code>setup.py</code>，可以实现用户在安装<code>ApiTestEngine</code>时自动安装<code>PyUnitReport</code>依赖。</p>
<p>对于这个需求，已经确定可行的办法：先通过<code>pip</code>安装依赖的库（<code>PyUnitReport</code>），然后再安装当前项目（<code>ApiTestEngine</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport</span><br><span class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</span><br></pre></td></tr></table></figure>
<p>这种方式虽然可行，但是需要执行两条命令，显然不是我们想要的效果。</p>
<p>经过搜索，发现针对该需求，可以在<code>setuptools.setup()</code>中通过<code>install_requires</code>和<code>dependency_links</code>这两个配置项组合实现。</p>
<p>具体地，配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">install_requires=[</span><br><span class="line">   &quot;requests&quot;,</span><br><span class="line">   &quot;flask&quot;,</span><br><span class="line">   &quot;PyYAML&quot;,</span><br><span class="line">   &quot;coveralls&quot;,</span><br><span class="line">   &quot;coverage&quot;,</span><br><span class="line">   &quot;PyUnitReport&quot;</span><br><span class="line">],</span><br><span class="line">dependency_links=[</span><br><span class="line">   &quot;git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>这里有一点需要格外注意，那就是指定的依赖包如果存在于<code>PyPI</code>，那么只需要在<code>install_requires</code>中指定包名和版本号即可（不指定版本号时，默认安装最新版本）；而对于以仓库URL地址存在的依赖包，那么不仅需要在<code>dependency_links</code>中指定，同时也要在<code>install_requires</code>中指定。</p>
<p>然后，就可以直接通过<code>ApiTestEngine</code>项目的git地址一键进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</span><br></pre></td></tr></table></figure>
<p>虽然在寻找解决办法的过程中，看到大家都在说<code>dependency_links</code>由于安全性的问题，即将被弃用，而且在<code>setuptools</code>的官方文章中的确也没有看到<code>dependency_links</code>的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEPRECATION: Dependency Links processing has been deprecated and will be removed in a future release.</span><br></pre></td></tr></table></figure>
<p>不过在我本地的<code>macOS</code>系统上尝试发现，该种方式的确是可行的，因此就采用这种方式进行发布了。</p>
<p>但是当我后续在<code>Linux</code>服务器上安装时，却无法成功，总是在安装<code>PyUnitReport</code>依赖库的时候报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</span><br><span class="line">[...]</span><br><span class="line">Collecting PyUnitReport (from ApiTestEngine)</span><br><span class="line">  Could not find a version that satisfies the requirement PyUnitReport (from ApiTestEngine) (from versions: )</span><br><span class="line">No matching distribution found for PyUnitReport (from ApiTestEngine)</span><br></pre></td></tr></table></figure>
<p>另外，同时也有多个用户反馈了同样的问题，这才发现这种方式在<code>Linux</code>和<code>Windows</code>下是不行的。</p>
<p>然后，再次经过大量的搜索，却始终没有特别明确的答案，搞得我也在怀疑，<code>dependency_links</code>到底是不是真的已经弃用了，但是就算是弃用了，也应该有新的替代方案啊，但也并没有找到。</p>
<p>这个问题就这么放了差不多一个星期的样子。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>今天周末在家，想来想去，不解决始终不爽，虽然只是多执行一条命令的问题。</p>
<p>于是又是经过大量搜索，幸运的是终于从<code>pypa/pip</code>的<code>issues</code>中找到一条<a href="https://github.com/pypa/pip/issues/3610" target="_blank" rel="noopener"><code>issue</code></a>，作者是<a href="https://github.com/pypa/pip/issues/3610#issue-147115114" target="_blank" rel="noopener"><code>Dominik Neise</code></a>，他详细描述了他遇到的问题和尝试过的方法，看到他的描述我真是惊呆了，跟我的情况完全一模一样不说，连尝试的思路也完全一致。</p>
<p>然后，在下面的回复中，看到了<a href="https://github.com/pypa/pip/issues/3610#issuecomment-283578756" target="_blank" rel="noopener"><code>Gary Wu</code></a>和<a href="https://github.com/pypa/pip/issues/3610#issuecomment-317281367" target="_blank" rel="noopener"><code>kbuilds</code></a>的解答，总算是找到了问题的原因和解决方案。</p>
<p>问题在于，在<code>dependency_links</code>中指定仓库URL地址的时候，在指定<code>egg</code>信息时，<code>pip</code>还同时需要一个版本号（<code>version number</code>），并且以短横线<code>-</code>分隔，然后执行的时候再加上<code>--process-dependency-links</code>参数。</p>
<p>回到之前的<code>dependency_links</code>，我们应该写成如下形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependency_links=[</span><br><span class="line">   &quot;git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport-0&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这里，短横线<code>-</code>后面我并没有填写<code>PyUnitReport</code>实际的版本号，因为经过尝试发现，这里填写任意数值都是成功的，因此我就填写为<code>0</code>了，省得后续在升级<code>PyUnitReport</code>以后还要来修改这个地方。</p>
<p>然后，就可以通过如下命令进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install --process-dependency-links git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</span><br></pre></td></tr></table></figure>
<p>至此，问题总算解决了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>那么，<code>dependency_links</code>到底是不是要废弃了呢？</p>
<p>从<code>pip</code>的<code>GitHub</code>项目中看到这么一个<a href="https://github.com/pypa/pip/issues/4187" target="_blank" rel="noopener"><code>issue</code></a>，<code>--process-dependency-links</code>之前废弃了一段时间，但是又给加回来了，因为当前还没有更好的可替代的方案。因此，在出现替代方案之前，<code>dependency_links</code>应该是最好的方式了吧。</p>
<p>最后再感叹下，老外提问时描述问题的专业性和细致程度真是令人佩服，大家可以再仔细看下这个<a href="https://github.com/pypa/pip/issues/3610#issue-147115114" target="_blank" rel="noopener"><code>issue</code></a>好好感受下。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#dependencies-that-aren-t-in-pypi" target="_blank" rel="noopener">http://setuptools.readthedocs.io/en/latest/setuptools.html#dependencies-that-aren-t-in-pypi</a></li>
<li><a href="https://pip.pypa.io/en/stable/reference/pip_install/" target="_blank" rel="noopener">https://pip.pypa.io/en/stable/reference/pip_install/</a></li>
<li><a href="https://github.com/pypa/pip/issues/3610" target="_blank" rel="noopener">https://github.com/pypa/pip/issues/3610</a></li>
<li><a href="https://github.com/pypa/pip/issues/4187" target="_blank" rel="noopener">https://github.com/pypa/pip/issues/4187</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/07/24/post/solve-Jenkins-can-not-show-html-css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/24/post/solve-Jenkins-can-not-show-html-css/" class="post-title-link" itemprop="url">解决 Jenkins 中无法展示 HTML 样式的问题</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-24 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-24T00:00:00+08:00">2017-07-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于测试报告来说，除了内容的简洁精炼，样式的美观也很重要。常用的做法是，采用<code>HTML</code>格式的文档，并搭配<code>CSS</code>和<code>JS</code>，实现自定义的样式和动画效果（例如展开、折叠等）。</p>
<p>在<code>Jenkins</code>中要展示<code>HTML</code>文档，通常采用的方式有两种：</p>
<ul>
<li>使用<a href="https://wiki.jenkins.io/display/JENKINS/HTML+Publisher+Plugin" target="_blank" rel="noopener"><code>HTML Publisher Plugin</code></a>；</li>
<li>使用<code>Files to archive</code>功能，在<code>Build Artifacts</code>中显示<code>HTML</code>文档链接。</li>
</ul>
<p>第一种方式配合插件，可以通过图形化操作实现简易配置，并且展示效果也不错；而第二种方式的优势在于使用<code>Jenkins</code>自带的功能，不依赖插件也能实现基本的需求。</p>
<p>然而，不管是采用哪种方式，都有可能会遇到一种情况，就是展示出来的<code>HTML</code>报告样式全无。在浏览器的<code>Network</code>中查看资源加载情况，会发现相关的<code>CSS</code>和<code>JS</code>都没法正常加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Refused to load the stylesheet &apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&apos; because it violates the following Content Security Policy directive: &quot;style-src &apos;self&apos;&quot;.</span><br><span class="line">Refused to apply inline style because it violates the following Content Security Policy directive: &quot;style-src &apos;self&apos;&quot;. Either the &apos;unsafe-inline&apos; keyword, a hash (&apos;sha256-0EZqoz+oBhx7gF4nvY2bSqoGyy4zLjNF+SDQXGp/ZrY=&apos;), or a nonce (&apos;nonce-...&apos;) is required to enable inline execution.</span><br><span class="line">Blocked script execution in &apos;http://10.13.0.146:8888/job/SkyPixel-SmokeTest/34/artifact/reports/SkyPixel-smoketest/34.html&apos; because the document&apos;s frame is sandboxed and the &apos;allow-scripts&apos; permission is not set.</span><br><span class="line">Refused to load the stylesheet &apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&apos; because it violates the following Content Security Policy directive: &quot;style-src &apos;self&apos;&quot;.</span><br></pre></td></tr></table></figure>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>出现该现象的原因在于<code>Jenkins</code>中配置的<code>CSP</code>（<code>Content Security Policy</code>）。</p>
<p>简单地说，这是<code>Jenkins</code>的一个安全策略，默认会设置为一个非常严格的权限集，以防止Jenkins用户在<code>workspace</code>、<code>/userContent</code>、<code>archived artifacts</code>中受到恶意<code>HTML/JS</code>文件的攻击。</p>
<p>默认地，该权限集会设置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sandbox; default-src &apos;none&apos;; img-src &apos;self&apos;; style-src &apos;self&apos;;</span><br></pre></td></tr></table></figure>
<p>在该配置下，只允许加载：</p>
<ul>
<li>Jenkins服务器上托管的<code>CSS</code>文件</li>
<li>Jenkins服务器上托管的图片文件</li>
</ul>
<p>而如下形式的内容都会被禁止：</p>
<ul>
<li>JavaScript</li>
<li>plugins (object/embed)</li>
<li>HTML中的内联样式表（<code>Inline style sheets</code>），以及引用的外站CSS文件</li>
<li>HTML中的内联图片（<code>Inline image definitions</code>），以及外站引用的图片文件</li>
<li>frames</li>
<li>web fonts</li>
<li>XHR/AJAX</li>
<li>etc.</li>
</ul>
<p>可以看出，这个限制非常严格，在此限制下也就不难理解为什么我们的<code>HTML</code>没法正常展示样式了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><p>要解决该问题，方式也比较简单，就是修改<code>Content Security Policy</code>的默认配置。</p>
<p>修改方式为，进入<code>Manage Jenkins</code>-&gt;<code>Script console</code>，输入如下命令并进行执行。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"hudson.model.DirectoryBrowserSupport.CSP"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>当看到如下结果后，则说明配置修改已经生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result</span><br><span class="line">Result:</span><br></pre></td></tr></table></figure>
<p>再次进行构建，新生成的<code>HTML</code>就可以正常展示样式了。需要说明的是，该操作对之前构建生成的<code>HTML</code>报告无效。</p>
<h3 id="永久解决方案"><a href="#永久解决方案" class="headerlink" title="永久解决方案"></a>永久解决方案</h3><p>不过，该方法还存在一个问题：该配置只是临时生效，当重启<code>Jenkins</code>后，<code>Content Security Policy</code>又会恢复为默认值，从而<code>HTML</code>样式又没法展示了。</p>
<p>当前，<code>Jenkins</code>官方还没有相应的解决方法，我们只能在每次启动或重启<code>Jenkins</code>时，重新修改该安全策略。</p>
<p>如果手工地来重复这项工作，也是可行，但并不是一个好的解决方案。</p>
<p>回到刚才的<code>Script console</code>，会发现我们执行的命令其实就是一段<code>Groovy</code>代码；那么，如果我们可以实现在<code>Jenkins</code>每次启动时自动地执行该<code>Groovy</code>代码，那么也就同样能解决我们的问题了。</p>
<p>好在<code>Jenkins</code>已经有相应的插件：</p>
<ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Startup+Trigger" target="_blank" rel="noopener"><code>Startup Trigger</code></a>: 可实现在<code>Jenkins</code>节点(master/slave)启动时触发构建；</li>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Groovy+plugin" target="_blank" rel="noopener"><code>Groovy plugin</code></a>: 可实现直接执行<code>Groovy</code>代码。</li>
</ul>
<p>搜索安装<code>startup-trigger-plugin</code>和<code>Groovy</code>插件后，我们就可以进行配置了。</p>
<p>配置方式如下：</p>
<ul>
<li>新建一个job，该job专门用于<code>Jenkins</code>启动时执行的配置命令；</li>
<li>在<code>Build Triggers</code>模块下，勾选<code>Build when job nodes start</code>；</li>
<li>在<code>Build</code>模块下，<code>Add build step</code>-&gt;<code>Execute system Groovy script</code>，在<code>Groovy Script</code>中输入配置命令，<code>System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)</code>。</li>
</ul>
<p>需要注意的是，添加构建步骤的时候，应该选择<code>Execute system Groovy script</code>，而不是<code>Execute Groovy script</code>。关于这两者之间的差异，简单地说，<code>Groovy Script</code>相当于是运行在<code>master/slave</code>系统<code>JVM</code>环境中，而<code>system groovy script</code>，则是运行在<code>Jenkins master</code>的<code>JVM</code>环境中，与前面提到的<code>Jenkins Script Console</code>功能相同。如需了解更多信息，可查看<a href="https://wiki.jenkins.io/display/JENKINS/Groovy+plugin" target="_blank" rel="noopener"><code>Groovy plugin</code>的详细说明</a>。</p>
<p>至此，我们就彻底解决<code>HTML</code>样式展示异常的问题了。</p>
<p>但还有一点需要格外注意，在本文的演示中，我们修改<code>CSP</code>（<code>Content Security Policy</code>）配置时关闭了的所有安全保护策略，即将<code>hudson.model.DirectoryBrowserSupport.CSP</code>设置为空，其实这是存在很大的安全隐患的。</p>
<p>正确的做法，我们应该是结合项目的实际情况，选择对应的安全策略。例如，如果我们需要开启脚本文件加载，但是只限于Jenkins服务器上托管的<code>CSS</code>文件，那么就可以采用如下配置。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"hudson.model.DirectoryBrowserSupport.CSP"</span>, <span class="string">"sandbox; style-src 'self';"</span>)</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>CSP</code>可以实现非常精细的权限配置，详细配置可参考<a href="https://content-security-policy.com/" target="_blank" rel="noopener"><code>Content Security Policy Reference</code></a>。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Configuring+Content+Security+Policy" target="_blank" rel="noopener">Configuring Content Security Policy</a></li>
<li><a href="https://content-security-policy.com/" target="_blank" rel="noopener">Content Security Policy Reference</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/07/17/post/ApiTestEngine-4-call-functions-in-yaml-testcases/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/17/post/ApiTestEngine-4-call-functions-in-yaml-testcases/" class="post-title-link" itemprop="url">ApiTestEngine 演进之路（4）测试用例中实现 Python 函数的调用</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-17 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-17T00:00:00+08:00">2017-07-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/" target="_blank" rel="noopener">《测试用例中实现<code>Python</code>函数的定义》</a>中，介绍了在<code>YAML/JSON</code>测试用例中实现<code>Python</code>函数定义的两种方法，以及它们各自适用的场景。</p>
<p>但是在<code>YAML/JSON</code>文本中要怎样实现函数的调用和传参呢？</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line"><span class="attr">   - TOKEN:</span> <span class="string">debugtalk</span></span><br><span class="line"><span class="attr">   - json:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">   - random:</span> <span class="string">$&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="attr">   - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br></pre></td></tr></table></figure>
<p>例如上面的例子（YAML格式），<code>gen_random_string</code>和<code>gen_md5</code>都是已经定义好的函数，但<code>${gen_random_string(5)}</code>和<code>${gen_md5($TOKEN, $json, $random)}</code>终究只是文本字符串，程序是如何将其解析为实际的函数和参数，并实现调用的呢？</p>
<p>本文将对此进行重点讲解。</p>
<h2 id="函数的调用形式"><a href="#函数的调用形式" class="headerlink" title="函数的调用形式"></a>函数的调用形式</h2><p>在<code>Python</code>语言中，函数的调用形式包含如下四种形式：</p>
<ul>
<li>无参数：func()</li>
<li>顺序参数：func(a, b)</li>
<li>字典参数：func(a=1, b=2)</li>
<li>混合类型参数：func(1, 2, a=3, b=4)</li>
</ul>
<p>之前在<a href="https://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/" target="_blank" rel="noopener">《探索优雅的测试用例描述方式》</a>中介绍过，我们选择使用<code>${}</code>作为函数转义符，在<code>YAML/JSON</code>用例描述中调用已经定义好的函数。</p>
<p>于是，以上四种类型的函数定义在<code>YAML/JSON</code>中就会写成如下样子。</p>
<ul>
<li>无参数：${func()}</li>
<li>顺序参数：${func(a, b)}</li>
<li>字典参数：${func(a=1, b=2)}</li>
<li>混合类型参数：${func(1, 2, a=3, b=4)}</li>
</ul>
<p>还是之前的例子：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    import_module_functions:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">tests.data.custom_functions</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - TOKEN:</span> <span class="string">debugtalk</span></span><br><span class="line"><span class="attr">        - json:</span> <span class="string">&#123;"name":</span> <span class="string">"user"</span><span class="string">,</span> <span class="string">"password"</span><span class="string">:</span> <span class="string">"123456"</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">        - random:</span> <span class="string">$&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="attr">        - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            authorization:</span> <span class="string">$authorization</span></span><br><span class="line"><span class="attr">            random:</span> <span class="string">$random</span></span><br><span class="line"><span class="attr">        json:</span> <span class="string">$json</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在这里面有一个<code>variables</code>模块，之前已经出现过很多次，也一直都没有讲解。但是，本文也不打算进行讲解，该部分内容将在下一篇讲解参数的定义和引用时再详细展开。</p>
<p>当前我们只需要知道，在该用例描述中，<code>${gen_random_string(5)}</code>和<code>${gen_md5($TOKEN, $json, $random)}</code>均实现了函数的传参和调用，而调用的函数正式之前我们定义的<code>gen_random_string</code>和<code>gen_md5</code>。</p>
<p>这里应该比较好理解，因为函数调用形式与在<code>Python</code>脚本中完全相同。但难点在于，这些描述在<code>YAML/JSON</code>中都是文本字符串形式，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>在加载测试用例的时候，是怎么识别出函数并完成调用的呢？</p>
<p>具体地，这里可以拆分为三个需求点：</p>
<ul>
<li>如何在<code>YAML/JSON</code>文本中识别函数？</li>
<li>如何将文本字符串的函数拆分为函数名称和参数？</li>
<li>如何使用函数名称和参数实现对应函数的调用？</li>
</ul>
<h2 id="正则表达式的妙用"><a href="#正则表达式的妙用" class="headerlink" title="正则表达式的妙用"></a>正则表达式的妙用</h2><p>对于第一个需求点，我们之前已经做好了铺垫，设计了<code>${}</code>作为函数的转义符；而当初之所以这么设计，也是为了在加载测试用例时便于解析识别，因为我们可以通过使用正则表达式，非常准确地将函数从文本格式的测试用例中提取出来。</p>
<p>既然<code>Python</code>函数的调用形式是确定的，都是<code>函数名(参数)</code>的形式，那么使用正则表达式的分组匹配功能，我们就可以很好地实现函数名称与参数的匹配，也就实现了第二个需求点。</p>
<p>例如，我们可以采用如下正则表达式，来对<code>YAML/JSON</code>中的每一个值（Value）进行匹配性检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r&quot;^\$\&#123;(\w+)\((.*)\)\&#125;$&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; regex = r<span class="string">"^\$\&#123;(\w+)\((.*)\)\&#125;$"</span></span><br><span class="line">&gt;&gt;&gt; string = <span class="string">"<span class="variable">$&#123;func(3, 5)&#125;</span>"</span></span><br><span class="line">&gt;&gt;&gt; matched = re.match(regex, string)</span><br><span class="line">&gt;&gt;&gt; matched.group(1)</span><br><span class="line"><span class="string">'func'</span></span><br><span class="line">&gt;&gt;&gt; matched.group(2)</span><br><span class="line"><span class="string">'3, 5'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; string = <span class="string">"<span class="variable">$&#123;func(a=1, b=2)&#125;</span>"</span></span><br><span class="line">&gt;&gt;&gt; matched = re.match(regex, string)</span><br><span class="line">&gt;&gt;&gt; matched.group(1)</span><br><span class="line"><span class="string">'func'</span></span><br><span class="line">&gt;&gt;&gt; matched.group(2)</span><br><span class="line"><span class="string">'a=1, b=2'</span></span><br></pre></td></tr></table></figure>
<p>可以看出，通过如上正则表达式，如果满足匹配条件，那么<code>matched.group(1)</code>就是函数的名称，<code>matched.group(2)</code>就是函数的参数。</p>
<p>思路是完全可行的，不过我们在匹配参数部分的时候是采用<code>.*</code>的形式，也就是任意字符匹配，匹配的方式不是很严谨。考虑到正常的函数参数部分可能使用到的字符，我们可以采用如下更严谨的正则表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r&quot;^\$\&#123;(\w+)\(([\$\w =,]*)\)\&#125;$&quot;</span><br></pre></td></tr></table></figure>
<p>这里限定了五种可能用到的字符，<code>\w</code>代表任意字母或数字，<code>= ,</code>代表的是等号、空格和逗号，这些都是参数中可能用到的。而<code>\$</code>符号，大家应该还记得，这也是我们设计采用的变量转义符，<code>$var</code>将不再代表的是普遍的字符串，而是<code>var</code>变量的值。</p>
<p>有了这个基础，实现如下<code>is_functon</code>函数，就可以判断某个字符串是否为函数调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function_regexp = re.compile(<span class="string">r"^\$\&#123;(\w+)\(([\$\w =,]*)\)\&#125;$"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_functon</span><span class="params">(content)</span>:</span></span><br><span class="line">    matched = function_regexp.match(content)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> matched <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>不过这里还有一个问题。通过上面的正则表达式，是可以将函数名称和参数部分拆分开了，但是在参数部分，还没法区分具体的参数类型。</p>
<p>例如，在前面的例子中，从<code>${func(3, 5)}</code>解析出来的参数为<code>3, 5</code>，从<code>${func(a=1, b=2)}</code>解析出来的参数为<code>a=1, b=2</code>，我们通过肉眼可以识别出这分别对应着顺序参数和字典参数两种类型，但是程序就没法自动识别了，毕竟对于程序来说它们都只是字符串而已。</p>
<p>所以，这里还需要再做一步操作，就是将参数字符串解析为对程序友好的形式。</p>
<p>什么叫对程序友好的形式呢？这里就又要用到<a href="https://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/" target="_blank" rel="noopener">上一篇文章</a>讲到的可变参数和关键字参数形式了，也就是<code>func(*args, **kwargs)</code>的形式。</p>
<p>试想，如果我们可以将所有顺序参数都转换为<code>args</code>列表，将所有字典参数都转换为<code>kwargs</code>字典，那么对于任意函数类型，我们都可以采用<code>func(*args, **kwargs)</code>的调用形式。</p>
<p>于是，问题就转换为，如何将参数部分转换为<code>args</code>和<code>kwargs</code>两部分。</p>
<p>这就比较简单了。因为在函数的参数部分，顺序参数必须位于字典参数前面，并且以逗号间隔；而字典参数呢，总是以<code>key=value</code>的形式出现，并且也以逗号间隔。</p>
<p>那么我们就可以利用参数部分的这个特征，来进行字符串的处理。处理算法如下：</p>
<ul>
<li>采用逗号作为分隔符将字符串进行拆分；</li>
<li>对每一部分进行判断，如果不包含等号，那么就是顺序参数，将其加入（<code>append</code>）到<code>args</code>列表；</li>
<li>如果包含等号，那么就是字典参数，采用等号作为分隔符进行进一步拆分得到<code>key-value</code>键值对，然后再加入到<code>kwargs</code>字典。</li>
</ul>
<p>对应的<code>Python</code>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_function</span><span class="params">(content)</span>:</span></span><br><span class="line">    function_meta = &#123;</span><br><span class="line">        <span class="string">"args"</span>: [],</span><br><span class="line">        <span class="string">"kwargs"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matched = function_regexp.match(content)</span><br><span class="line">    function_meta[<span class="string">"func_name"</span>] = matched.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    args_str = matched.group(<span class="number">2</span>).replace(<span class="string">" "</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span> args_str == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> function_meta</span><br><span class="line"></span><br><span class="line">    args_list = args_str.split(<span class="string">','</span>)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'='</span> <span class="keyword">in</span> arg:</span><br><span class="line">            key, value = arg.split(<span class="string">'='</span>)</span><br><span class="line">            function_meta[<span class="string">"kwargs"</span>][key] = parse_string_value(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            function_meta[<span class="string">"args"</span>].append(parse_string_value(arg))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function_meta</span><br></pre></td></tr></table></figure>
<p>可以看出，通过<code>parse_function</code>函数，可以将一个函数调用的字符串转换为函数的结构体。</p>
<p>例如，<code>${func(1, 2, a=3, b=4)}</code>字符串，经过<code>parse_function</code>转换后，就可以得到该函数的名称和参数信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function_meta = &#123;</span><br><span class="line">    'func_name': 'func',</span><br><span class="line">    'args': [1, 2],</span><br><span class="line">    'kwargs': &#123;'a':3, 'b':4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就彻底解决了第二个需求点。</p>
<h2 id="实现函数的调用"><a href="#实现函数的调用" class="headerlink" title="实现函数的调用"></a>实现函数的调用</h2><p>在此基础上，我们再看第三个需求点，如何使用函数名称和参数实现对应函数的调用，其实也就很简单了。</p>
<p>在<a href="https://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/" target="_blank" rel="noopener">上一篇文章</a>中，我们实现了对函数的定义，并且将所有定义好的函数都添加到了一个字典当中，假如字典名称为<code>custom_functions_dict</code>，那么根据以上的函数信息（<code>function_meta</code>），就可以采用如下方式进行调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func_name = function_meta[<span class="string">'func_name'</span>]</span><br><span class="line">args = function_meta[<span class="string">'args'</span>]</span><br><span class="line">kwargs = function_meta[<span class="string">'kwargs'</span>]</span><br><span class="line">custom_functions_dict[func_name](*args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>具体的，在<code>ApiTestEngine</code>中对应的<code>Python</code>代码片段如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_eval_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">   <span class="string">""" evaluate data recursively, each variable in data will be evaluated.</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">   <span class="keyword">if</span> isinstance(data, (list, tuple)):</span><br><span class="line">       <span class="keyword">return</span> [self.get_eval_value(item) <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> isinstance(data, dict):</span><br><span class="line">       evaluated_data = &#123;&#125;</span><br><span class="line">       <span class="keyword">for</span> key, value <span class="keyword">in</span> data.items():</span><br><span class="line">           evaluated_data[key] = self.get_eval_value(value)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> evaluated_data</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> isinstance(data, (int, float)):</span><br><span class="line">       <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">   <span class="comment"># data is in string format here</span></span><br><span class="line">   data = <span class="string">""</span> <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> data.strip()</span><br><span class="line">   <span class="keyword">if</span> utils.is_variable(data):</span><br><span class="line">       <span class="comment"># variable marker: $var</span></span><br><span class="line">       variable_name = utils.parse_variable(data)</span><br><span class="line">       value = self.testcase_variables_mapping.get(variable_name)</span><br><span class="line">       <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">raise</span> exception.ParamsError(</span><br><span class="line">               <span class="string">"%s is not defined in bind variables!"</span> % variable_name)</span><br><span class="line">       <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">   <span class="keyword">elif</span> utils.is_functon(data):</span><br><span class="line">       <span class="comment"># function marker: $&#123;func(1, 2, a=3, b=4)&#125;</span></span><br><span class="line">       fuction_meta = utils.parse_function(data)</span><br><span class="line">       func_name = fuction_meta[<span class="string">'func_name'</span>]</span><br><span class="line">       args = fuction_meta.get(<span class="string">'args'</span>, [])</span><br><span class="line">       kwargs = fuction_meta.get(<span class="string">'kwargs'</span>, &#123;&#125;)</span><br><span class="line">       args = self.get_eval_value(args)</span><br><span class="line">       kwargs = self.get_eval_value(kwargs)</span><br><span class="line">       <span class="keyword">return</span> self.testcase_config[<span class="string">"functions"</span>][func_name](*args, **kwargs)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>这里还用到了递归的概念，当参数是变量（例如<code>gen_md5($TOKEN, $json, $random)</code>），或者为列表、字典等嵌套类型时，也可以实现正常的解析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，我们就解决了测试用例（<code>YAML/JSON</code>）中实现<code>Python</code>函数定义和调用的问题。</p>
<p>还记得<a href="https://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/" target="_blank" rel="noopener">《探索优雅的测试用例描述方式》</a>末尾提到的用例模板引擎技术实现的三大块内容么？</p>
<ul>
<li>如何在用例描述（<code>YAML/JSON</code>）中实现函数的定义和调用</li>
<li>如何在用例描述中实现参数的定义和引用，包括用例内部和用例集之间</li>
<li>如何在用例描述中实现预期结果的描述和测试结果的校验</li>
</ul>
<p>第一块总算是讲完了，下一篇文章将开始讲解如何在用例描述中实现参数的定义和引用的问题。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（3）测试用例中实现<code>Python</code>函数的定义》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/07/11/post/ApiTestEngine-3-define-functions-in-yaml-testcases/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/11/post/ApiTestEngine-3-define-functions-in-yaml-testcases/" class="post-title-link" itemprop="url">ApiTestEngine 演进之路（3）测试用例中实现 Python 函数的定义</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-11T00:00:00+08:00">2017-07-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》</a>中，我们臆想了一种简洁优雅的用例描述方式，接下来，我们就从技术实现的角度，逐项进行深入讲解，将臆想变成现实。</p>
<p>本文先解决第一个问题，“如何在用例描述（<code>YAML/JSON</code>）中实现函数的定义和调用”。</p>
<blockquote>
<p>在写作的过程中，发现要将其中的原理阐述清楚，要写的内容实在是太多，因此将问题再拆分为“函数定义”和“函数调用”两部分，本文只讲解“函数定义”部分的内容。</p>
</blockquote>
<h2 id="实现函数的定义"><a href="#实现函数的定义" class="headerlink" title="实现函数的定义"></a>实现函数的定义</h2><p>在之前，我们假设存在<code>gen_random_string</code>这样一个生成指定位数随机字符串的函数，以及<code>gen_md5</code>这样一个计算签名校验值的函数，我们不妨先尝试通过<code>Python</code>语言进行具体的实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(</span><br><span class="line">        random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_md5</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(<span class="string">""</span>.join(args).encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line">gen_random_string(<span class="number">5</span>) <span class="comment"># =&gt; A2dEx</span></span><br><span class="line"></span><br><span class="line">TOKEN = <span class="string">"debugtalk"</span></span><br><span class="line">data = <span class="string">'&#123;"name": "user", "password": "123456"&#125;'</span></span><br><span class="line">random = <span class="string">"A2dEx"</span></span><br><span class="line">gen_md5(TOKEN, data, random) <span class="comment"># =&gt; a83de0ff8d2e896dbd8efb81ba14e17d</span></span><br></pre></td></tr></table></figure>
<p>熟悉<code>Python</code>语言的人对以上代码应该都不会有理解上的难度。可能部分新接触<code>Python</code>的同学对<code>gen_md5</code>函数的<code>*args</code>传参方式会比较陌生，我也简单地补充下基础知识。</p>
<p>在<code>Python</code>中，函数参数共有四种，必选参数、默认参数、可变参数和关键字参数。</p>
<p>必选参数和默认参数大家应该都很熟悉，绝大多数编程语言里面都有类似的概念。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y, a=<span class="number">1</span>, b=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y + a + b</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># =&gt; 6</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, b=<span class="number">3</span>) <span class="comment"># =&gt; 7</span></span><br></pre></td></tr></table></figure>
<p>在上面例子中，<code>x</code>和<code>y</code>是必选参数，<code>a</code>和<code>b</code>是默认参数。除了显示地定义必选参数和默认参数，我们还可以通过使用可变参数和关键字参数的形式，实现更灵活的函数参数定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(args) + sum(kwargs.values())</span><br><span class="line"></span><br><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">kwargs = &#123;<span class="string">'a'</span>:<span class="number">3</span>, <span class="string">'b'</span>:<span class="number">4</span>&#125;</span><br><span class="line">func(*args, **kwargs) <span class="comment"># =&gt; 10</span></span><br><span class="line"></span><br><span class="line">args = []</span><br><span class="line">kwargs = &#123;<span class="string">'a'</span>:<span class="number">3</span>, <span class="string">'b'</span>:<span class="number">4</span>, <span class="string">'c'</span>: <span class="number">5</span>&#125;</span><br><span class="line">func(*args, **kwargs) <span class="comment"># =&gt; 12</span></span><br></pre></td></tr></table></figure>
<p>之所以说更灵活，是因为当使用可变参数和关键字参数时（<code>func(*args, **kwargs)</code>），我们在调用函数时就可以传入0个或任意多个必选参数和默认参数，所有必选参数将作为<code>tuple/list</code>的形式传给可变参数（<code>args</code>），并将所有默认参数作为<code>dict</code>的形式传给关键字参数（<code>kwargs</code>）。另外，可变参数和关键字参数也并不是要同时使用，只使用一种也是可以的。</p>
<p>在前面定义的<code>gen_md5(*args)</code>函数中，我们就可以将任意多个字符串传入，然后得到拼接字符串的<code>MD5</code>值。</p>
<p>现在再回到测试用例描述文件，由于是纯文本格式（<code>YAML/JSON</code>），我们没法直接写<code>Python</code>代码，那要怎样才能定义函数呢？</p>
<p>之前接触过一些函数式编程，所以我首先想到的是借助<code>lambda</code>实现匿名函数。如果对函数式编程不了解，可以看下我之前写过的一篇文章，<a href="https://debugtalk.com/post/python-functional-programming-getting-started/" target="_blank" rel="noopener">《Python的函数式编程–从入门到⎡放弃⎦》</a>。</p>
<h2 id="方法一：通过lambda实现函数定义"><a href="#方法一：通过lambda实现函数定义" class="headerlink" title="方法一：通过lambda实现函数定义"></a>方法一：通过lambda实现函数定义</h2><p>使用<code>lambda</code>有什么好处呢？</p>
<p>最简单直接的一点，通过<code>lambda</code>关键字，我们可以将函数写到一行里面。例如，同样是前面提到的<code>gen_random_string</code>函数和<code>gen_md5</code>函数，通过<code>lambda</code>的实现方式就是如下的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gen_random_string = <span class="keyword">lambda</span> str_len: <span class="string">''</span>.join(random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len))</span><br><span class="line">gen_md5 = <span class="keyword">lambda</span> *str_args: hashlib.md5(<span class="string">''</span>.join(str_args).encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">gen_random_string(<span class="number">5</span>) <span class="comment"># =&gt; A2dEx</span></span><br><span class="line"></span><br><span class="line">TOKEN = <span class="string">"debugtalk"</span></span><br><span class="line">data = <span class="string">'&#123;"name": "user", "password": "123456"&#125;'</span></span><br><span class="line">random = <span class="string">"A2dEx"</span></span><br><span class="line">gen_md5(TOKEN, data, random) <span class="comment"># =&gt; a83de0ff8d2e896dbd8efb81ba14e17d</span></span><br></pre></td></tr></table></figure>
<p>可以看出，采用<code>lambda</code>定义的函数跟之前的函数功能完全一致，调用方式相同，运算结果也完全一样。</p>
<p>然后，我们在测试用例里面，通过新增一个<code>function_binds</code>模块，就可以将函数定义与函数名称绑定了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    function_binds:</span></span><br><span class="line"><span class="attr">        gen_random_string:</span> <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></span><br><span class="line"><span class="attr">        gen_md5:</span> <span class="string">"lambda *str_args: hashlib.md5(''.join(str_args).encode('utf-8'))</span></span><br><span class="line"><span class="string">    variables:</span></span><br><span class="line"><span class="string">        - TOKEN: debugtalk</span></span><br><span class="line"><span class="string">        - random: $&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="string">        - json: &#123;"</span><span class="string">name":</span> <span class="string">"user"</span><span class="string">,</span> <span class="string">"password"</span><span class="string">:</span> <span class="string">"123456"</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">        - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br></pre></td></tr></table></figure>
<p>可能有些同学还是无法理解，在上面<code>YAML</code>文件中，即使将函数定义与函数名称绑定了，但是加载<code>YAML</code>文件后，函数名称对应的值也只是一个字符串而已，这还是没法运行啊。</p>
<p>这就又要用到<code>eval</code>黑科技了。通过<code>eval</code>函数，可以执行字符串表达式，并返回表达式的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gen_random_string = <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></span><br><span class="line"></span><br><span class="line">func = eval(gen_random_string)</span><br><span class="line"></span><br><span class="line">func <span class="comment"># =&gt; &lt;function &lt;lambda&gt; at 0x10e19a398&gt;</span></span><br><span class="line">func(<span class="number">5</span>) <span class="comment"># =&gt; "A2dEx"</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>gen_random_string</code>为<code>lambda</code>字符串表达式，通过<code>eval</code>执行后，就转换为一个函数对象，然后就可以像正常定义的函数一样调用了。</p>
<p>如果你看到这里还没有疑问，那么说明你肯定没有亲自实践。事实上，上面执行<code>func(5)</code>的时候并不会返回预期结果，而是会抛出如下异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; func(5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;string&gt;"</span>, line 1, <span class="keyword">in</span> &lt;lambda&gt;</span><br><span class="line">  File <span class="string">"&lt;string&gt;"</span>, line 1, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">NameError: global name <span class="string">'random'</span> is not defined</span><br></pre></td></tr></table></figure>
<p>这是因为，我们在定义的<code>lambda</code>函数中，用到了<code>random</code>库，而在<code>lambda</code>表达式中，我们并没有<code>import random</code>。</p>
<p>这下麻烦了，很多时候我们的函数都要用到标准库或者第三方库，而在调用这些库函数之前，我们必须得先<code>import</code>。想来想去，这个<code>import</code>的操作都没法塞到<code>lambda</code>表达式中。</p>
<p>为了解决这个依赖库的问题，我想到两种方式。</p>
<p>第一种方式，在加载<code>YAML/JSON</code>用例之前，先统一将测试用例依赖的所有库都<code>import</code>一遍。这个想法很快就被否决了，因为这必须要在<code>ApiTestEngine</code>框架里面去添加这部分代码，而且每个项目的依赖库不一样，需要<code>import</code>的库也不一样，总不能为了解决这个问题，在框架初始化部分将所有的库都<code>import</code>吧？而且为了适配不同项目来改动测试框架的代码，也不是通用测试框架应有的做法。</p>
<p>然后我想到了第二种方式，就是在测试用例里面，通过新增一个<code>requires</code>模块，罗列出当前测试用例所有需要引用的库，然后在加载用例的时候通过代码动态地进行导入依赖库。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    requires:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">random</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">string</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">hashlib</span></span><br><span class="line"><span class="attr">    function_binds:</span></span><br><span class="line"><span class="attr">        gen_random_string:</span> <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></span><br><span class="line"><span class="attr">        gen_md5:</span> <span class="string">"lambda *str_args: hashlib.md5(''.join(str_args).encode('utf-8'))</span></span><br><span class="line"><span class="string">    variables:</span></span><br><span class="line"><span class="string">        - TOKEN: debugtalk</span></span><br><span class="line"><span class="string">        - random: $&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="string">        - json: &#123;"</span><span class="string">name":</span> <span class="string">"user"</span><span class="string">,</span> <span class="string">"password"</span><span class="string">:</span> <span class="string">"123456"</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">        - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br></pre></td></tr></table></figure>
<p>动态地导入依赖库？其实也没有多玄乎，<code>Python</code>本身也支持这种特性。如果你看到这里感觉无法理解，那么我再补充点基础知识。</p>
<p>在<code>Python</code>中执行<code>import</code>时，实际上等价于执行<code>__import__</code>函数。</p>
<p>例如，<code>import random</code>等价于如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random = __import__(<span class="string">'random'</span>, globals(), locals(), [], <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>其中，<code>__import__</code>的函数定义为<code>__import__(name[, globals[, locals[, fromlist[, level]]]])</code>，第一个参数为库的名称，后面的参数暂不用管（可直接查看<a href="https://docs.python.org/3/library/functions.html#__import__" target="_blank" rel="noopener">官方文档</a>）。</p>
<p>由于后面的参数都有默认值，通常情况下我们采用默认值即可，因此我们也可以简化为如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random = __import__(<span class="string">'random'</span>)</span><br></pre></td></tr></table></figure>
<p>执行这个语句的有什么效果呢？</p>
<p>可能这也是大多数<code>Python</code>初学者都忽略的一个知识点。在<code>Python</code>运行环境中，有一个全局的环境变量，当我们定义一个函数，或者引入一个依赖库时，实际上就是将其对象添加到了全局的环境变量中。</p>
<p>这个全局的环境变量就是<code>globals()</code>，它是一个字典类型的数据结构。要验证以上知识点，我们可以在<code>Python</code>的交互终端中进行如下实验。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; globals()</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;class <span class="string">'_frozen_importlib.BuiltinImporter'</span>&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import random</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; globals()</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;class <span class="string">'_frozen_importlib.BuiltinImporter'</span>&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'random'</span>: &lt;module <span class="string">'random'</span> from <span class="string">'/Users/Leo/.pyenv/versions/3.6.0/lib/python3.6/random.py'</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在执行<code>import random</code>命令后，<code>globals()</code>中就新增了<code>random</code>函数的引用。</p>
<p>因此，导入<code>random</code>依赖库时，我们采用如下的写法也是等价的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_name = ”random“</span><br><span class="line">globals()[module_name] = __import__(module_name)</span><br></pre></td></tr></table></figure>
<p>更进一步，<code>__import__</code>作为<code>Python</code>的底层函数，其实是不推荐直接调用的。要实现同样的功能，推荐使用<code>importlib.import_module</code>。替换后就变成了如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_name = ”random“</span><br><span class="line">globals()[module_name] = importlib.import_module(module_name)</span><br></pre></td></tr></table></figure>
<p>如果理解了以上的知识点，那么再给我们一个依赖库名称（字符串形式）的列表时，我们就可以实现动态的导入（<code>import</code>）了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_requires</span><span class="params">(modules)</span>:</span></span><br><span class="line">   <span class="string">""" import required modules dynamicly</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">   <span class="keyword">for</span> module_name <span class="keyword">in</span> modules:</span><br><span class="line">       globals()[module_name] = importlib.import_module(module_name)</span><br></pre></td></tr></table></figure>
<p>在实现了定义<code>lambda</code>函数的<code>function_binds</code>和导入依赖库的<code>requires</code>模块之后，我们就可以在<code>YAML/JSON</code>中灵活地描述测试用例了。</p>
<p>还是之前的例子，完整的测试用例描述形式就为如下样子。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    requires:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">random</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">string</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">hashlib</span></span><br><span class="line"><span class="attr">    function_binds:</span></span><br><span class="line"><span class="attr">        gen_random_string:</span> <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></span><br><span class="line"><span class="attr">        gen_md5:</span> <span class="string">"lambda *str_args: hashlib.md5(''.join(str_args).encode('utf-8')).hexdigest()"</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - TOKEN:</span> <span class="string">debugtalk</span></span><br><span class="line"><span class="attr">        - random:</span> <span class="string">$&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="attr">        - data:</span> <span class="string">'&#123;"name": "user", "password": "123456"&#125;'</span></span><br><span class="line"><span class="attr">        - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$data,</span> <span class="string">$random)&#125;</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            authorization:</span> <span class="string">$authorization</span></span><br><span class="line"><span class="attr">            random:</span> <span class="string">$random</span></span><br><span class="line"><span class="attr">        data:</span> <span class="string">$data</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以在<code>YAML/JSON</code>文本中⎡灵活⎦地定义函数，实现各种功能了。</p>
<p>可是，这真的是我们期望的样子么？</p>
<p>开始的时候，我们想在自动化测试中将<code>测试数据</code>与<code>代码实现</code>进行分离，于是我们引入了<code>YAML/JSON</code>格式的用例形式；为了在<code>YAML/JSON</code>文本格式中实现签名校验等计算功能，我们又引入了<code>function_binds</code>模块，并通过<code>lambda</code>定义函数并与函数名进行绑定；再然后，为了解决定义函数中的依赖库问题，我们又引入了<code>requires</code>模块，动态地加载指定的依赖库。</p>
<p>而且即使是这样，这种方式也有一定的局限性，当函数较复杂的时候，我们很难将函数内容转换为<code>lambda</code>表达式；虽然理论上所有的函数都能转换为<code>lamda</code>表达式，但是实现的难度会非常高。</p>
<p>为了不写代码而人为引入了更多更复杂的概念和技术，这已经不再符合我们的初衷了。于是，我开始重新寻找新的实现方式。</p>
<h2 id="方法二：自定义函数模块并进行导入"><a href="#方法二：自定义函数模块并进行导入" class="headerlink" title="方法二：自定义函数模块并进行导入"></a>方法二：自定义函数模块并进行导入</h2><p>让我们再回归基础概念，当我们调用一个函数的时候，究竟发生了什么？</p>
<p>简单的说，不管是调用一个函数，还是引用一个变量，都会在当前的运行环境上下文（<code>context</code>）中寻找已经定义好的函数或变量。而在<code>Python</code>中，当我们加载一个模块（<code>module</code>）的时候，就会将该模块中的所有函数、变量、类等对象加载进当前的运行环境上下文。</p>
<p>如果单纯地看这个解释还不清楚，想必大家应该都见过如下案例的形式。假设<code>moduleA</code>模块包含如下定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># moduleA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, %s"</span> % name</span><br><span class="line"></span><br><span class="line">varA = <span class="string">"I am varA"</span></span><br></pre></td></tr></table></figure>
<p>那么，我们就可以通过如下方式导入<code>moduleA</code>模块中所有内容，并且直接调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moduleA <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">print(hello(<span class="string">"debugtalk"</span>)) <span class="comment"># =&gt; hello, debugtalk</span></span><br><span class="line">print(varA) <span class="comment"># =&gt; I am varA</span></span><br></pre></td></tr></table></figure>
<p>明确这一点后，既然我们之前都可以动态地导入（<code>import</code>）依赖库，那么我们不妨再进一步，我们同样也可以动态地导入已经定义好的函数啊。</p>
<p>只要我们先在一个<code>Python</code>模块文件中定义好测试用例所需的函数，然后在运行测试用例的时候设法将模块中的所有函数导入即可。</p>
<p>于是，问题就转换为，如何在<code>YAML/JSON</code>中实现<code>from moduleA import *</code>机制。</p>
<p>经过摸索，我发现了<code>Python</code>的<a href="https://docs.python.org/3/library/functions.html#vars" target="_blank" rel="noopener"><code>vars</code>函数</a>，这也是<code>Python</code>的<code>Built-in Functions</code>之一。</p>
<p>对于<code>vars</code>，官方的定义如下：</p>
<blockquote>
<p>Return the <code>__dict__</code> attribute for a module, class, instance, or any other object with a <code>__dict__</code> attribute.</p>
</blockquote>
<p>简言之，就是<code>vars()</code>可以将模块（<code>module</code>）、类（<code>class</code>）、实例（<code>instance</code>）或者任意对象的所有属性（包括但不限于定义的方法和变量），以字典的形式返回。</p>
<p>还是前面举例的<code>moduelA</code>，相信大家看完下面这个例子就清晰了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import moduleA</span><br><span class="line">&gt;&gt;&gt; vars(moduleA)</span><br><span class="line">&gt;&gt;&gt; &#123;<span class="string">'hello'</span>: &lt;<span class="keyword">function</span> hello at 0x1072fcd90&gt;, <span class="string">'varA'</span>: <span class="string">'I am varA'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>掌握了这一层理论基础，我们就可以继续改造我们的测试框架了。</p>
<p>我采取的做法是，在测试用例中新增一个<code>import_module_functions</code>模块，里面可填写多个模块的路径。而测试用例中所有需要使用的函数，都定义在对应路径的模块中。</p>
<p>我们再回到之前的案例，在测试用例中需要用到<code>gen_random_string</code>和<code>gen_md5</code>这两个函数函数，那么就可以将其定义在一个模块中，假设模块名称为<code>custom_functions.py</code>，相对于项目根目录的路径为<code>tests/data/custom_functions.py</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(</span><br><span class="line">        random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_md5</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(<span class="string">""</span>.join(args).encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这里的模块文件可以放置在系统的任意路径下，但是一定要保证它可作为<code>Python</code>的模块进行访问，也就是说在该文件的所有父目录中，都包含<code>__init__.py</code>文件。这是<code>Python</code>的语法要求，如不理解可查看官方文档。</p>
<p>然后，在<code>YAML/JSON</code>测试用例描述的<code>import_module_functions</code>栏目中，我们就可以写为<code>tests.data.custom_functions</code>。</p>
<p>新的用例描述形式就变成了如下样子。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    import_module_functions:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">tests.data.custom_functions</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - TOKEN:</span> <span class="string">debugtalk</span></span><br><span class="line"><span class="attr">        - json:</span> <span class="string">&#123;"name":</span> <span class="string">"user"</span><span class="string">,</span> <span class="string">"password"</span><span class="string">:</span> <span class="string">"123456"</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">        - random:</span> <span class="string">$&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="attr">        - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            authorization:</span> <span class="string">$authorization</span></span><br><span class="line"><span class="attr">            random:</span> <span class="string">$random</span></span><br><span class="line"><span class="attr">        json:</span> <span class="string">$json</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在函数已经定义好了，那是怎样实现动态加载的呢？</p>
<p>首先，还是借助于<code>importlib.import_module</code>，实现模块的导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imported = importlib.import_module(module_name)</span><br></pre></td></tr></table></figure>
<p>然后，借助于<code>vars</code>函数，可以获取得到模块的所有属性，也就是其中定义的方法、变量等对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(imported)</span><br></pre></td></tr></table></figure>
<p>不过，由于我们只需要定义的函数，因此我们还可以通过进行过滤，只获取模块中的所有方法对象。当然，这一步不是必须的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imported_functions_dict = dict(filter(is_function, vars(imported).items()))</span><br></pre></td></tr></table></figure>
<p>其中，<code>is_function</code>是一个检测指定对象是否为方法的函数，实现形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_function</span><span class="params">(tup)</span>:</span></span><br><span class="line">    <span class="string">""" Takes (name, object) tuple, returns True if it is a function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name, item = tup</span><br><span class="line">    <span class="keyword">return</span> isinstance(item, types.FunctionType)</span><br></pre></td></tr></table></figure>
<p>通过以上代码，就实现了从指定外部模块加载所有方法的功能。完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_module_functions</span><span class="params">(self, modules, level=<span class="string">"testcase"</span>)</span>:</span></span><br><span class="line">   <span class="string">""" import modules and bind all functions within the context</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">   <span class="keyword">for</span> module_name <span class="keyword">in</span> modules:</span><br><span class="line">       imported = importlib.import_module(module_name)</span><br><span class="line">       imported_functions_dict = dict(filter(is_function, vars(imported).items()))</span><br><span class="line">       self.__update_context_config(level, <span class="string">"functions"</span>, imported_functions_dict)</span><br></pre></td></tr></table></figure>
<p>结合到实际项目，我们就可以采取这种协作模式：</p>
<ul>
<li>由测试开发或者开发人员将项目中所有依赖的逻辑实现为函数方法，统一放置到一个模块中；</li>
<li>在<code>YAML/JSON</code>测试用例中，对模块进行引用；（对于测试用例集的模式，只需要引用一次，以后再详细讲解）</li>
<li>业务测试人员只需要关注接口的业务数据字段，设计测试用例即可。</li>
</ul>
<p>可以看出，这也算是软件工程和实际项目中的一种权衡之计，但好处在于能充分发挥各岗位角色人员的职能，有助于接口测试自动化工作的顺利开展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了在<code>YAML/JSON</code>测试用例中实现<code>Python</code>函数定义的两种方法：</p>
<ul>
<li>通过<code>lambda</code>实现函数的定义：该种方式适用于函数比较简单的情况，并且函数最好没有依赖库；虽然复杂的函数也能采用这种方式进行定义，但可能会存在一定的局限性，而且看上去也比较累赘。</li>
<li>自定义函数模块并进行导入：该种方式通用性更强，所有类型的函数都可以通过这种方式进行定义和引用；但由于需要编写额外的<code>Python</code>模块文件，在函数比较简单的情况下反而会显得较为繁琐，此时采用<code>lambda</code>形式会更简洁。</li>
</ul>
<p>到现在为止，我们已经清楚了如何在<code>YAML/JSON</code>测试用例中实现函数的定义，但是在<code>YAML/JSON</code>文本中要怎样实现函数的调用和传参呢？</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line"><span class="attr">   - TOKEN:</span> <span class="string">debugtalk</span></span><br><span class="line"><span class="attr">   - json:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">   - random:</span> <span class="string">$&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="attr">   - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br></pre></td></tr></table></figure>
<p>例如上面的例子（YAML格式），<code>gen_random_string</code>和<code>gen_md5</code>都是已经定义好的函数，但<code>${gen_random_string(5)}</code>和<code>${gen_md5($TOKEN, $json, $random)}</code>终究只是文本字符串，程序是如何将其解析为真实的函数和参数，并实现调用的呢？</p>
<p>下篇文章再详细讲解。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://debugtalk.com/post/python-functional-programming-getting-started/" target="_blank" rel="noopener">《Python的函数式编程–从入门到⎡放弃⎦》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/07/07/post/ApiTestEngine-2-best-testcase-description/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/07/post/ApiTestEngine-2-best-testcase-description/" class="post-title-link" itemprop="url">ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-07T00:00:00+08:00">2017-07-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（1）搭建基础框架》</a>一文中，我们完成了<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>基础框架的搭建，并实现了简单接口的测试功能。</p>
<p>接下来，我们就针对复杂类型的接口（例如包含签名校验等机制），通过对接口的业务参数和技术细节进行分离，实现简洁优雅的接口测试用例描述。</p>
<h2 id="传统的测试用例编写方式"><a href="#传统的测试用例编写方式" class="headerlink" title="传统的测试用例编写方式"></a>传统的测试用例编写方式</h2><p>对于在自动化测试中将<code>测试数据</code>与<code>代码实现</code>进行分离的好处，我之前已经讲过多次，这里不再重复。</p>
<p>测试数据与代码实现分离后，简单的接口还好，测试用例编写不会有什么问题；但是当面对复杂一点的接口（例如包含签名校验等机制）时，我们编写自动化测试用例还是会比较繁琐。</p>
<p>我们从一个最常见的案例入手，看下编写自动化测试用例的过程，相信大家看完后就会对上面那段话有很深的感受。</p>
<p>以API接口服务（<code>Mock Server</code>）的创建新用户功能为例，该接口描述如下：</p>
<blockquote>
<p>请求数据：<br>Url: <a href="http://127.0.0.1:5000/api/users/1000" target="_blank" rel="noopener">http://127.0.0.1:5000/api/users/1000</a><br>Method: POST<br>Headers: {“content-type”: “application/json”, “Random”: “A2dEx”, “Authorization”: “47f135c33e858f2e3f55156ae9f78ee1”}<br>Body: {“name”: “user1”, “password”: “123456”}</p>
<p>预期的正常响应数据：<br>Status_Code: 201<br>Headers: {‘Date’: ‘Fri, 23 Jun 2017 07:05:41 GMT’, ‘Content-Length’: ‘54’, ‘Content-Type’: ‘application/json’, ‘Server’: ‘Werkzeug/0.12.2 Python/2.7.13’}<br>Body: {“msg”: “user created successfully.”, “success”: true, “uuid”: “JsdfwerL”}</p>
</blockquote>
<p>其中，请求<code>Headers</code>中的<code>Random</code>字段是一个5位长的随机字符串，<code>Authorization</code>字段是一个签名值，签名方式为<code>TOKEN+RequestBody+Random</code>拼接字符串的<code>MD5</code>值。更具体的，<code>RequestBody</code>要求字典的<code>Key</code>值按照由小到大的排序方式。接口请求成功后，返回的是一个<code>JSON</code>结构，里面的<code>success</code>字段标识请求成功与否的状态，如果成功，<code>uuid</code>字段标识新创建用户的唯一ID。</p>
<p>相信只要是接触过接口测试的同学对此应该都会很熟悉，这也是后台系统普遍采用的签名校验方式。在具体的系统中，可能字符串拼接方式或签名算法存在差异，但是模式基本上都是类似的。</p>
<p>那么面对这样一个接口，我们会怎样编写接口测试用例呢？</p>
<p>首先，请求的数据是要有的，我们会先准备一个可用的账号，例如<code>{&quot;password&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;user1&quot;}</code>。</p>
<p>然后，由于接口存在签名校验机制，因此我们除了要知道服务器端使用的TOKEN（假设为<code>debugtalk</code>）外，还要准备好<code>Random</code>字段和<code>Authorization</code>字段。<code>Random</code>字段好说，我们随便生成一个，例如<code>A2dEx</code>；<code>Authorization</code>字段就会复杂不少，需要我们按照规定先将<code>RequestBody</code>根据字典的<code>Key</code>值进行排序，得到<code>{&quot;name&quot;: &quot;user1&quot;, &quot;password&quot;: &quot;123456&quot;}</code>，然后与<code>TOKEN</code>和<code>Random</code>字段拼接字符串得到<code>debugtalk{&quot;password&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;user1&quot;}A2dEx</code>，接着再找一个<code>MD5</code>工具，计算得到签名值<code>a83de0ff8d2e896dbd8efb81ba14e17d</code>。</p>
<p>最后，我们才可以完成测试用例的编写。假如我们采用<code>YAML</code>编写测试用例，那么用例写好后应该就是如下样子。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            authorization:</span> <span class="string">a83de0ff8d2e896dbd8efb81ba14e17d</span></span><br><span class="line"><span class="attr">            random:</span> <span class="string">A2dEx</span></span><br><span class="line"><span class="attr">    data:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">user1</span></span><br><span class="line"><span class="attr">        password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">        status_code:</span> <span class="number">201</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">        body:</span></span><br><span class="line"><span class="attr">            success:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">            msg:</span> <span class="string">user</span> <span class="string">created</span> <span class="string">successfully.</span></span><br><span class="line"><span class="attr">            uuid:</span> <span class="string">JsdfwerL</span></span><br></pre></td></tr></table></figure>
<p>该测试用例可以在<code>ApiTestEngine</code>中正常运行，我们也可以采用同样的方式，对系统的所有接口编写测试用例，以此实现项目的接口自动化测试覆盖。</p>
<p>但问题在于，每个接口通常会对应多条测试用例，差异只是在于请求的数据会略有不同，而测试用例量越大，我们人工去准备测试数据的工作量也就越大。更令人抓狂的是，我们的系统接口不是一直不变的，有时候会根据业务需求的变化进行一些调整，相应地，我们的测试数据也需要进行同步更新，这样一来，所有相关的测试用例数据就又得重新计算一遍（任意字段数据产生变化，签名值就会大不相同）。</p>
<p>可以看出，如果是采用这种方式编写维护接口测试用例，人力和时间成本都会非常高，最终的结果必然是接口自动化测试难以在实际项目中得以开展。</p>
<h2 id="理想的用例描述方式"><a href="#理想的用例描述方式" class="headerlink" title="理想的用例描述方式"></a>理想的用例描述方式</h2><p>在上面案例中，编写接口测试用例时之所以会很繁琐，主要是因为接口存在签名校验机制，导致我们在准备测试数据时耗费了太多时间在这上面。</p>
<p>然而，对于测试人员来说，接口的业务功能才是需要关注的，至于接口采用什么签名校验机制这类技术细节，的确不应耗费过多时间和精力。所以，我们的接口测试框架应该设法将接口的技术细节实现和业务参数进行拆分，并能自动处理与技术细节相关的部分，从而让业务测试人员只需要关注业务参数部分。</p>
<p>那要怎么实现呢？</p>
<p>在开始实现之前，我们不妨借鉴<code>BDD</code>（行为驱动开发）的思想，先想下如何编写接口测试用例的体验最友好，换句话说，就是让业务测试人员写用例写得最爽。</p>
<p>还是上面案例的接口测试用例，可以看出，最耗时的地方主要是计算签名校验值部分。按理说，签名校验算法我们是已知的，要是可以在测试用例中直接调用签名算法函数就好了。</p>
<p>事实上，这也是各种模板语言普遍采用的方式，例如<code>Jinja2</code>模板语言，可以在<code>{% %}</code>中执行函数语句，在<code>{{ }}</code>中可以调用变量参数。之前我在设计[<code>AppiumBooster</code>][AppiumBooster]时也采用了类似的思想，可以通过<code>${config.TestEnvAccount.UserName}</code>的方式在测试用例中引用预定义的全局变量。</p>
<p>基于该思路，假设我们已经实现了<code>gen_random_string</code>这样一个生成指定位数的随机字符串的函数，以及<code>gen_md5</code>这样一个计算签名校验值的函数，那么我们就可以尝试采用如下方式来描述我们的测试用例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - TOKEN:</span> <span class="string">debugtalk</span></span><br><span class="line"><span class="attr">        - random:</span> <span class="string">$&#123;gen_random_string(5)&#125;</span></span><br><span class="line"><span class="attr">        - json:</span> <span class="string">&#123;"name":</span> <span class="string">"user"</span><span class="string">,</span> <span class="string">"password"</span><span class="string">:</span> <span class="string">"123456"</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">        - authorization:</span> <span class="string">$&#123;gen_md5($TOKEN,</span> <span class="string">$json,</span> <span class="string">$random)&#125;</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            authorization:</span> <span class="string">$authorization</span></span><br><span class="line"><span class="attr">            random:</span> <span class="string">$random</span></span><br><span class="line"><span class="attr">        json:</span> <span class="string">$json</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        user_uuid:</span> <span class="string">content.uuid</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在如上用例中，用到了两种转义符：</p>
<ul>
<li><code>$</code>作为变量转义符，<code>$var</code>将不再代表的是普遍的字符串，而是<code>var</code>变量的值；</li>
<li><code>${}</code>作为函数的转义符，<code>${}</code>内可以直接填写函数名称及调用参数，甚至可以包含变量。</li>
</ul>
<p>为什么会选择采用这种描述方式？（<code>Why？</code>）</p>
<p>其实这也是我经过大量思考和实践之后，才最终确定的描述方式。如果真要讲述这个思路历程。。。还是不细说了，此处可省下一万字。（主要的思路无非就是要实现转义的效果，并且表达要简洁清晰，因此必然会用到特殊字符；而特殊字符在<code>YAML</code>中大多都已经有了特定的含义，排除掉不可用的之后，剩下的真没几个了，然后再借鉴其它框架常用的符号，所以说最终选择<code>$</code>和<code>${}</code>也算是必然。）</p>
<p>可以确定的是，这种描述方式的好处非常明显，不仅可以实现复杂计算逻辑的函数调用，还可以实现变量的定义和引用。</p>
<p>除了转义符，由于接口测试中经常需要对结果中的特定字段进行提取，作为后续接口请求的参数，因此我们实现了<code>extractors</code>这样一个结果提取器，只要返回结果是JSON类型，就可以将其中的任意字段进行提取，并保存到一个变量中，方便后续接口请求进行引用。</p>
<p>另外，为了更好地实现对接口响应结果的校验，我们废弃了先前的方式，实现了独立的结果校验器<code>validators</code>。这是因为，很多时候在比较响应结果时，并不能简单地按照字段值是否相等来进行校验，除此之外，我们可能还需要检查某个字段的长度是否为指定位数，元素列表个数是否大于某个数值，甚至某个字符串是否满足正则匹配等等。</p>
<p>相信你们肯定会想，以上这些描述方式的确是很简洁，但更多地感觉是在臆想，就像开始说的<code>gen_random_string</code>和<code>gen_md5</code>函数，我们只是假设已经定义好了。就算描述得再优雅再完美，终究也还只是<code>YAML/JSON</code>文本格式而已，要怎样才能转换为执行的代码呢？</p>
<p>这就要解决<code>How？</code>的问题了。</p>
<p>嗯，这就是用例模板引擎的核心了，也算是<code>ApiTestEngine</code>最核心的功能特性。</p>
<p>更具体的，从技术实现角度，主要分为三大块：</p>
<ul>
<li>如何在用例描述（<code>YAML/JSON</code>）中实现函数的定义和调用</li>
<li>如何在用例描述中实现参数的定义和引用，包括用例内部和用例集之间</li>
<li>如何在用例描述中实现预期结果的描述和测试结果的校验</li>
</ul>
<p>这三大块内容涉及到较多的技术实现细节，我们将在后续的文章中结合代码逐个深入进行讲解。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/" target="_blank" rel="noopener">《ApiTestEngine 演化之路（0）开发未动，测试先行》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（1）搭建基础框架》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/06/28/post/300-lines-python-code-api-test-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/28/post/300-lines-python-code-api-test-framework/" class="post-title-link" itemprop="url">300 行 Python 代码打造实用接口测试框架</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-28 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-28T00:00:00+08:00">2017-06-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在刚开始实现<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>的时候，<a href="https://testerhome.com/kasi" target="_blank" rel="noopener"><code>卡斯（kasi）</code></a>提议做一个Java版的。对于这样的建议，我当然是拒绝的，瞬即回复了他，“人生苦短，回头是岸啊”。</p>
<p>当然，我没好意思跟他说的是，我不会Java啊。不过最主要的原因嘛，还是因为Python的语法简洁，可以采用很少的代码量实现丰富的功能。</p>
<p>有多简洁呢？</p>
<p>刚在<code>coveralls</code>上看了下<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>框架的<a href="https://coveralls.io/github/debugtalk/ApiTestEngine?branch=master" target="_blank" rel="noopener">代码统计行数</a>，总行数只有268行，还不足300行。</p>
<p><img src="/images/ApiTestEngine-stat-ate.jpg" alt></p>
<p>当然，这个行数指的是框架本身的<code>Python</code>代码行数，不包括示例注释的行数。从上图可以看出来，<code>LINES</code>列是文件总行数，<code>RELEVANT</code>列是实际的<code>Python</code>代码行数。例如<code>ate/runner.py</code>文件，注释的行数是远多于实际代码行数的。</p>
<p>最极端的一个例子是，<code>ate/testcase.py</code>文件中的<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/ate/testcase.py" target="_blank" rel="noopener"><code>parse</code>函数</a>，示例注释行数35行，<code>Python</code>代码只有2行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, testcase_template)</span>:</span></span><br><span class="line">   <span class="string">""" parse testcase_template, replace all variables with bind value.</span></span><br><span class="line"><span class="string">   variables marker: $&#123;variable&#125;.</span></span><br><span class="line"><span class="string">   @param (dict) testcase_template</span></span><br><span class="line"><span class="string">       &#123;</span></span><br><span class="line"><span class="string">           "request": &#123;</span></span><br><span class="line"><span class="string">               "url": "http://127.0.0.1:5000/api/users/$&#123;uid&#125;",</span></span><br><span class="line"><span class="string">               "method": "POST",</span></span><br><span class="line"><span class="string">               "headers": &#123;</span></span><br><span class="line"><span class="string">                   "Content-Type": "application/json",</span></span><br><span class="line"><span class="string">                   "authorization": "$&#123;authorization&#125;",</span></span><br><span class="line"><span class="string">                   "random": "$&#123;random&#125;"</span></span><br><span class="line"><span class="string">               &#125;,</span></span><br><span class="line"><span class="string">               "body": "$&#123;data&#125;"</span></span><br><span class="line"><span class="string">           &#125;,</span></span><br><span class="line"><span class="string">           "response": &#123;</span></span><br><span class="line"><span class="string">               "status_code": "$&#123;expected_status&#125;"</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">   @return (dict) parsed testcase with bind values</span></span><br><span class="line"><span class="string">       &#123;</span></span><br><span class="line"><span class="string">           "request": &#123;</span></span><br><span class="line"><span class="string">               "url": "http://127.0.0.1:5000/api/users/1000",</span></span><br><span class="line"><span class="string">               "method": "POST",</span></span><br><span class="line"><span class="string">               "headers": &#123;</span></span><br><span class="line"><span class="string">                   "Content-Type": "application/json",</span></span><br><span class="line"><span class="string">                   "authorization": "a83de0ff8d2e896dbd8efb81ba14e17d",</span></span><br><span class="line"><span class="string">                   "random": "A2dEx"</span></span><br><span class="line"><span class="string">               &#125;,</span></span><br><span class="line"><span class="string">               "body": '&#123;"name": "user", "password": "123456"&#125;'</span></span><br><span class="line"><span class="string">           &#125;,</span></span><br><span class="line"><span class="string">           "response": &#123;</span></span><br><span class="line"><span class="string">               "status_code": 201</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">   <span class="keyword">return</span> self.substitute(testcase_template)</span><br></pre></td></tr></table></figure>
<p>另外，如果算上单元测试用例的行数（731行），总的<code>Python</code>代码行数能达到1000行的样子。嗯，代码可以精简，但是单元测试覆盖率还是要保证的，不达到90%以上的单元测试覆盖率，真不好意思说自己做了开源项目啊。</p>
<p><img src="/images/ApiTestEngine-stat-all.jpg" alt></p>
<p>那这不足300行的Python代码，实际实现了哪些功能呢？</p>
<p>对比下<a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>中规划的特性，已经实现了大半（前六项），至少已经算是一个有模有样的接口测试框架了。</p>
<ul>
<li>支持API接口的多种请求方法，包括 GET/POST/HEAD/PUT/DELETE 等</li>
<li>测试用例与代码分离，测试用例维护方式简洁优雅，支持<code>YAML/JSON</code></li>
<li>测试用例描述方式具有表现力，可采用简洁的方式描述输入参数和预期输出结果</li>
<li>接口测试用例具有可复用性，便于创建复杂测试场景</li>
<li>测试执行方式简单灵活，支持单接口调用测试、批量接口调用测试、定时任务执行测试</li>
<li>具有可扩展性，便于扩展实现Web平台化</li>
<li>测试结果统计报告简洁清晰，附带详尽日志记录，包括接口请求耗时、请求响应数据等</li>
<li>身兼多职，同时实现接口管理、接口自动化测试、接口性能测试（结合Locust）</li>
</ul>
<p>后面剩下的特性还在实现的过程中，但是可以预见得到，最后框架本身总的<code>Python</code>代码行数也不会超过500行。</p>
<p>当然，单纯地比代码行数的确是没有什么意义，写得爽写得开心才是最重要的。</p>
<p>最后引用下<code>Guido van Rossum</code>的语录：</p>
<blockquote>
<p>Life is short, go Pythonic!</p>
</blockquote>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/" target="_blank" rel="noopener">《ApiTestEngine 演化之路（0）开发未动，测试先行》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（1）搭建基础框架》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p><a href="https://debugtalk.com/tags/ApiTestEngine" target="_blank" rel="noopener">《ApiTestEngine 演进之路》</a>系列文章还在继续写，只是前几天主要精力在编码实现上，博客方面没有同步更新，接下来我会整理好思路，继续完成余下的部分。</p>
<p>另外，如果大家对Python编程感兴趣，给大家推荐一个专注Python原创技术分享的公众号，⎡Python之禅⎦（VTtalk），里面关于Python的干货非常多，讲解也很通俗易懂，现在我如果有理解得不够透彻的概念，基本都会先到这个公众号里面去搜索下。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/06/22/post/ApiTestEngine-1-setup-basic-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/22/post/ApiTestEngine-1-setup-basic-framework/" class="post-title-link" itemprop="url">ApiTestEngine 演进之路（1）搭建基础框架</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-22 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-22T00:00:00+08:00">2017-06-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（0）开发未动，测试先行》</a>一文中，我对<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>项目正式开始前的准备工作进行了介绍，包括构建API接口服务（<code>Mock Server</code>）、搭建项目单元测试框架、实现持续集成构建检查机制（<a href="https://travis-ci.org/" target="_blank" rel="noopener"><code>Travis CI</code></a>）等。</p>
<p>接下来，我们就开始构建<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>项目的基础框架，实现基本功能吧。</p>
<h2 id="接口测试的核心要素"><a href="#接口测试的核心要素" class="headerlink" title="接口测试的核心要素"></a>接口测试的核心要素</h2><p>既然是从零开始，那我们不妨先想下，对于接口测试来说，最基本最核心的要素有哪些？</p>
<p>事实上，不管是手工进行接口测试，还是自动化测试平台执行接口测试，接口测试的核心要素都可以概括为如下三点：</p>
<ul>
<li>发起接口请求（Request）</li>
<li>解析接口响应（Response）</li>
<li>检查接口测试结果</li>
</ul>
<p>这对于任意类型的接口测试也都是适用的。</p>
<p>在本系列文章中，我们关注的是API接口的测试，更具体地，是基于HTTP协议的API接口的测试。所以我们的问题就进一步简化了，只需要关注<code>HTTP</code>协议层面的请求和响应即可。</p>
<p>好在对于绝大多数接口系统，都有明确的API接口文档，里面会定义好接口请求的参数（包括Headers和Body），并同时描述好接口响应的内容（包括Headers和Body）。而我们需要做的，就是根据接口文档的描述，在<code>HTTP</code>请求中按照接口规范填写请求的参数，然后读取接口的<code>HTTP</code>响应内容，将接口的实际响应内容与我们的预期结果进行对比，以此判断接口功能是否正常。这里的预期结果，应该是包含在接口测试用例里面的。</p>
<p>由此可知，实现接口测试框架的第一步是完成对<code>HTTP</code>请求响应处理的支持。</p>
<h2 id="HTTP客户端的最佳选择"><a href="#HTTP客户端的最佳选择" class="headerlink" title="HTTP客户端的最佳选择"></a>HTTP客户端的最佳选择</h2><p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>项目选择<code>Python</code>作为编程语言，而在<code>Python</code>中实现<code>HTTP</code>请求，毫无疑问，<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>库是最佳选择，简洁优雅，功能强大，可轻松支持<code>API</code>接口的多种请求方法，包括<code>GET/POST/HEAD/PUT/DELETE</code>等。</p>
<p>并且，更赞的地方在于，<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>库针对所有的<code>HTTP</code>请求方法，都可以采用一套统一的接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.request(method, url, **kwargs)</span><br></pre></td></tr></table></figure>
<p>其中，<code>kwargs</code>中可以包含<code>HTTP</code>请求的所有可能需要用到的信息，例如<code>headers</code>、<code>cookies</code>、<code>params</code>、<code>data</code>、<code>auth</code>等。</p>
<p>这有什么好处呢？</p>
<p>好处在于，这可以帮助我们轻松实现测试数据与框架代码的分离。我们只需要遵循<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>库的参数规范，在接口测试用例中复用<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>参数的概念即可。而对于框架的测试用例执行引擎来说，处理逻辑就异常简单了，直接读取测试用例中的参数，传参给<code>Requests</code>发起请求即可。</p>
<p>如果还感觉不好理解，没关系，直接看案例。</p>
<h2 id="测试用例描述"><a href="#测试用例描述" class="headerlink" title="测试用例描述"></a>测试用例描述</h2><p>在我们搭建的API接口服务（<code>Mock Server</code>）中，我们想测试“创建一个用户，该用户之前不存在”的场景</p>
<p>在上一篇文章中，我们也在<code>unittest</code>中对该测试场景实现了测试脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_create_user_not_existed</span><span class="params">(self)</span>:</span></span><br><span class="line">   self.clear_users()</span><br><span class="line"></span><br><span class="line">   url = <span class="string">"%s/api/users/%d"</span> % (self.host, <span class="number">1000</span>)</span><br><span class="line">   data = &#123;</span><br><span class="line">       <span class="string">"name"</span>: <span class="string">"user1"</span>,</span><br><span class="line">       <span class="string">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">   &#125;</span><br><span class="line">   resp = self.api_client.post(url, json=data)</span><br><span class="line"></span><br><span class="line">   self.assertEqual(<span class="number">201</span>, resp.status_code)</span><br><span class="line">   self.assertEqual(<span class="literal">True</span>, resp.json()[<span class="string">"success"</span>])</span><br></pre></td></tr></table></figure>
<p>在该用例中，我们实现了<code>HTTP POST</code>请求，<code>api_client.post(url, json=data)</code>，然后对响应结果进行解析，并检查<code>resp.status_code</code>、<code>resp.json()[&quot;success&quot;]</code>是否满足预期。</p>
<p>可以看出，采用代码编写测试用例时会用到许多编程语言的语法，对于不会编程的人来说上手难度较大。更大的问题在于，当我们编写大量测试用例之后，因为模式基本都是固定的，所以会发现存在大量相似或重复的脚本，这给脚本的维护带来了很大的问题。</p>
<p>那如何将测试用例与脚本代码进行分离呢？</p>
<p>考虑到<code>JSON</code>格式在编程语言中处理是最方便的，分离后的测试用例可采用<code>JSON</code>描述如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"create user which does not exist"</span>,</span><br><span class="line">   <span class="attr">"request"</span>: &#123;</span><br><span class="line">       <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:5000/api/users/1000"</span>,</span><br><span class="line">       <span class="attr">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">       <span class="attr">"headers"</span>: &#123;</span><br><span class="line">           <span class="attr">"content-type"</span>: <span class="string">"application/json"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">"json"</span>: &#123;</span><br><span class="line">           <span class="attr">"name"</span>: <span class="string">"user1"</span>,</span><br><span class="line">           <span class="attr">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"response"</span>: &#123;</span><br><span class="line">       <span class="attr">"status_code"</span>: <span class="number">201</span>,</span><br><span class="line">       <span class="attr">"headers"</span>: &#123;</span><br><span class="line">           <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">"body"</span>: &#123;</span><br><span class="line">           <span class="attr">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">           <span class="attr">"msg"</span>: <span class="string">"user created successfully."</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，如上<code>JSON</code>结构体包含了测试用例的完整描述信息。</p>
<p>需要特别注意的是，这里使用了一个讨巧的方式，就是在请求的参数中充分复用了<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>的参数规范。例如，我们要<code>POST</code>一个<code>JSON</code>的结构体，那么我们就直接将<code>json</code>作为<code>request</code>的参数名，这和前面写脚本时用的<code>api_client.post(url, json=data)</code>是一致的。</p>
<h2 id="测试用例执行引擎"><a href="#测试用例执行引擎" class="headerlink" title="测试用例执行引擎"></a>测试用例执行引擎</h2><p>在如上测试用例描述的基础上，测试用例执行引擎就很简单了，以下几行代码就足够了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_single_testcase</span><span class="params">(testcase)</span>:</span></span><br><span class="line">   req_kwargs = testcase[<span class="string">'request'</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       url = req_kwargs.pop(<span class="string">'url'</span>)</span><br><span class="line">       method = req_kwargs.pop(<span class="string">'method'</span>)</span><br><span class="line">   <span class="keyword">except</span> KeyError:</span><br><span class="line">       <span class="keyword">raise</span> exception.ParamsError(<span class="string">"Params Error"</span>)</span><br><span class="line"></span><br><span class="line">   resp_obj = requests.request(url=url, method=method, **req_kwargs)</span><br><span class="line">   diff_content = utils.diff_response(resp_obj, testcase[<span class="string">'response'</span>])</span><br><span class="line">   success = <span class="literal">False</span> <span class="keyword">if</span> diff_content <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">   <span class="keyword">return</span> success, diff_content</span><br></pre></td></tr></table></figure>
<p>可以看出，不管是什么<code>HTTP</code>请求方法的用例，该执行引擎都是适用的。</p>
<p>只需要先从测试用例中获取到HTTP接口请求参数，<code>testcase[&#39;request&#39;]</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:5000/api/users/1000"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">      <span class="attr">"content-type"</span>: <span class="string">"application/json"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"json"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"user1"</span>,</span><br><span class="line">      <span class="attr">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后发起<code>HTTP</code>请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.request(url=url, method=method, **req_kwargs)</span><br></pre></td></tr></table></figure>
<p>最后再检查测试结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">utils.diff_response(resp_obj, testcase[<span class="string">'response'</span>])</span><br></pre></td></tr></table></figure>
<p>在测试用例执行引擎完成后，执行测试用例的方式也很简单。同样是在<code>unittest</code>中调用执行测试用例，就可以写成如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run_single_testcase_success</span><span class="params">(self)</span>:</span></span><br><span class="line">   testcase_file_path = os.path.join(os.getcwd(), <span class="string">'tests/data/demo.json'</span>)</span><br><span class="line">   testcases = utils.load_testcases(testcase_file_path)</span><br><span class="line">   success, _ = self.test_runner.run_single_testcase(testcases[<span class="number">0</span>])</span><br><span class="line">   self.assertTrue(success)</span><br></pre></td></tr></table></figure>
<p>可以看出，模式还是很固定：加载用例、执行用例、判断用例执行是否成功。如果每条测试用例都要在<code>unittest.TestCase</code>分别写一个单元测试进行调用，还是会存在大量重复工作。</p>
<p>所以比较好的做法是，再实现一个单元测试用例生成功能；这部分先不展开，后面再进行详细描述。</p>
<h2 id="结果判断处理逻辑"><a href="#结果判断处理逻辑" class="headerlink" title="结果判断处理逻辑"></a>结果判断处理逻辑</h2><p>这里再单独讲下对结果的判断逻辑处理，也就是<code>diff_response</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff_response</span><span class="params">(resp_obj, expected_resp_json)</span></span></span><br><span class="line">    diff_content = &#123;&#125;</span><br><span class="line">    resp_info = parse_response_object(resp_obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对比 status_code，将差异存入 diff_content</span></span><br><span class="line">    <span class="comment"># 对比 Headers，将差异存入 diff_content</span></span><br><span class="line">    <span class="comment"># 对比 Body，将差异存入 diff_content</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff_content</span><br></pre></td></tr></table></figure>
<p>其中，<code>expected_resp_json</code>参数就是我们在测试用例中描述的<code>response</code>部分，作为测试用例的预期结果描述信息，是判断实际接口响应是否正常的参考标准。</p>
<p>而<code>resp_obj</code>参数，就是实际接口响应的<code>Response</code>实例，详细的定义可以参考<code>requests.Response</code><a href="http://docs.python-requests.org/en/master/api/#requests.Response" target="_blank" rel="noopener">描述文档</a>。</p>
<p>为了更好地实现结果对比，我们也将<code>resp_obj</code>解析为与<code>expected_resp_json</code>相同的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_response_object</span><span class="params">(resp_obj)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp_body = resp_obj.json()</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        resp_body = resp_obj.text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'status_code'</span>: resp_obj.status_code,</span><br><span class="line">        <span class="string">'headers'</span>: resp_obj.headers,</span><br><span class="line">        <span class="string">'body'</span>: resp_body</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么最后再进行对比就很好实现了，只需要编写一个通用的<code>JSON</code>结构体比对函数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff_json</span><span class="params">(current_json, expected_json)</span>:</span></span><br><span class="line">    json_diff = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, expected_value <span class="keyword">in</span> expected_json.items():</span><br><span class="line">        value = current_json.get(key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> str(value) != str(expected_value):</span><br><span class="line">            json_diff[key] = &#123;</span><br><span class="line">                <span class="string">'value'</span>: value,</span><br><span class="line">                <span class="string">'expected'</span>: expected_value</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json_diff</span><br></pre></td></tr></table></figure>
<p>这里只罗列了核心处理流程的代码实现，其它的辅助功能，例如加载<code>JSON/YAML</code>测试用例等功能，请直接阅读阅读<a href="https://github.com/debugtalk/ApiTestEngine/tree/master/ate" target="_blank" rel="noopener">项目源码</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过本文中的工作，我们已经完成了<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>基础框架的搭建，并实现了两项最基本的功能：</p>
<ul>
<li>支持API接口的多种请求方法，包括 GET/POST/HEAD/PUT/DELETE 等</li>
<li>测试用例与代码分离，测试用例维护方式简洁优雅，支持<code>YAML/JSON</code></li>
</ul>
<p>然而，在实际项目中的接口通常比较复杂，例如包含签名校验等机制，这使得我们在配置接口测试用例时还是会比较繁琐。</p>
<p>在下一篇文章中，我们将着手解决这个问题，通过对框架增加模板配置功能，实现接口业务参数和技术细节的分离。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="https://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/" target="_blank" rel="noopener">《ApiTestEngine 演进之路（0）开发未动，测试先行》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/06/20/post/ApiTestEngine-0-setup-CI-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="solomiss">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/huzi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="理想国">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/20/post/ApiTestEngine-0-setup-CI-test/" class="post-title-link" itemprop="url">ApiTestEngine 演进之路（0）开发未动，测试先行</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-20T00:00:00+08:00">2017-06-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-03 21:15:10" itemprop="dateModified" datetime="2019-04-03T21:15:10+08:00">2019-04-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/" itemprop="url" rel="index"><span itemprop="name">Development</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Development/测试框架/" itemprop="url" rel="index"><span itemprop="name">测试框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>一文中，我详细介绍了<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>诞生的背景，并对其核心特性进行了详尽的剖析。</p>
<p>接下来，我将在《ApiTestEngine演进之路》系列文章中讲解<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>是如何从第一行代码开始，逐步实现接口自动化测试框架的核心功能特性的。</p>
<p>相信大家都有听说过<code>TDD</code>（<code>测试驱动开发</code>）这种开发模式，虽然网络上对该种开发模式存在异议，但我个人是非常推荐使用该种开发方式的。关于<code>TDD</code>的优势，我就不在此赘述了，我就只说下自己受益最深的两个方面。</p>
<ul>
<li>测试驱动，其实也是需求驱动。在开发正式代码之前，可以先将需求转换为单元测试用例，然后再逐步实现正式代码，直至将所有单元测试用例跑通。这可以帮助我们总是聚焦在要实现的功能特性上，避免跑偏。特别是像我们做测试开发的，通常没有需求文档和设计文档，如果没有清晰的思路，很可能做着做着就不知道自己做到哪儿了。</li>
<li>高覆盖率的单元测试代码，对项目质量有充足的信心。因为是先写测试再写实现，所以正常情况下，所有的功能特性都应该能被单元测试覆盖到。再结合持续集成的手段，我们可以轻松保证每个版本都是高质量并且可用的。</li>
</ul>
<p>所以，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>项目也将采用<code>TDD</code>的开发模式。本篇文章就重点介绍下采用<code>TDD</code>之前需要做的一些准备工作。</p>
<h2 id="搭建API接口服务（Mock-Server）"><a href="#搭建API接口服务（Mock-Server）" class="headerlink" title="搭建API接口服务（Mock Server）"></a>搭建API接口服务（Mock Server）</h2><p>接口测试框架要运行起来，必然需要有可用的API接口服务。因此，在开始构建我们的接口测试框架之前，最好先搭建一套简单的API接口服务，也就是<code>Mock Server</code>，然后我们在采用<code>TDD</code>开发模式的时候，就可以随时随地将框架代码跑起来，开发效率也会大幅提升。</p>
<p>为什么不直接采用已有的业务系统API接口服务呢？</p>
<p>这是因为通常业务系统的接口比较复杂，并且耦合了许多业务逻辑，甚至还可能涉及到和其它业务系统的交互，搭建或维护一套测试环境的成本可能会非常高。另一方面，接口测试框架需要具有一定的通用性，其功能特性很难在一个特定的业务系统中找到所有合适的接口。就拿最简单的接口请求方法来说，测试框架需要支持<code>GET/POST/HEAD/PUT/DELETE</code>方法，但是可能在我们已有的业务系统中只有<code>GET/POST</code>接口。</p>
<p>自行搭建API接口服务的另一个好处在于，我们可以随时调整接口的实现方式，来满足接口测试框架特定的功能特性，从而使我们总是能将注意力集中在测试框架本身。比较好的做法是，先搭建最简单的接口服务，在此基础上将接口测试框架搭建起来，实现最基本的功能；后面在实现框架的高级功能特性时，我们再对该接口服务进行拓展升级，例如增加签名校验机制等，来适配测试框架的高级功能特性。</p>
<p>幸运的是，使用<code>Python</code>搭建API接口服务十分简单，特别是在结合使用<a href="http://flask.pocoo.org/" target="_blank" rel="noopener"><code>Flask</code></a>框架的情况下。</p>
<p>例如，我们想实现一套可以对用户账号进行增删改查（<code>CRUD</code>）功能的接口服务，用户账号的存储结构大致如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users_dict = &#123;</span><br><span class="line">   'uid1': &#123;</span><br><span class="line">       'name': 'name1',</span><br><span class="line">       'password': 'pwd1'</span><br><span class="line">   &#125;,</span><br><span class="line">   'uid2': &#123;</span><br><span class="line">       'name': 'name2',</span><br><span class="line">       'password': 'pwd2'</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，新增（Create）和更新（Update）功能的接口就可以通过如下方式实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, make_response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">users_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/api/users/&lt;int:uid&gt;', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(uid)</span>:</span></span><br><span class="line">    user = request.get_json()</span><br><span class="line">    <span class="keyword">if</span> uid <span class="keyword">not</span> <span class="keyword">in</span> users_dict:</span><br><span class="line">        result = &#123;</span><br><span class="line">            <span class="string">'success'</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">"user created successfully."</span></span><br><span class="line">        &#125;</span><br><span class="line">        status_code = <span class="number">201</span></span><br><span class="line">        users_dict[uid] = user</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = &#123;</span><br><span class="line">            <span class="string">'success'</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">'msg'</span>: <span class="string">"user already existed."</span></span><br><span class="line">        &#125;</span><br><span class="line">        status_code = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    response = make_response(json.dumps(result), status_code)</span><br><span class="line">    response.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/api/users/&lt;int:uid&gt;', methods=['PUT'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_user</span><span class="params">(uid)</span>:</span></span><br><span class="line">    user = users_dict.get(uid, &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> user:</span><br><span class="line">        user = request.get_json()</span><br><span class="line">        success = <span class="literal">True</span></span><br><span class="line">        status_code = <span class="number">200</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        success = <span class="literal">False</span></span><br><span class="line">        status_code = <span class="number">404</span></span><br><span class="line"></span><br><span class="line">    result = &#123;</span><br><span class="line">        <span class="string">'success'</span>: success,</span><br><span class="line">        <span class="string">'data'</span>: user</span><br><span class="line">    &#125;</span><br><span class="line">    response = make_response(json.dumps(result), status_code)</span><br><span class="line">    response.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>限于篇幅，其它类型的接口实现就不在此赘述，完整的接口实现可以参考<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/tests/api_server.py" target="_blank" rel="noopener">项目源码</a>。</p>
<p>接口服务就绪后，按照<code>Flask</code>官方文档，可以通过如下方式进行启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export FLASK_APP=tests/api_server.py</span><br><span class="line">$ flask run</span><br><span class="line"> * Serving Flask app &quot;tests.api_server&quot;</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>
<p>启动后，我们就可以通过请求接口来调用已经实现的接口功能了。例如，先创建一个用户，然后查看所有用户的信息，在<code>Python</code>终端中的调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python 3.6.0 (default, Mar 24 2017, 16:58:25)</span><br><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; requests.post(&apos;http://127.0.0.1:5000/api/users/1000&apos;, json=&#123;&apos;name&apos;: &apos;user1&apos;, &apos;password&apos;: &apos;123456&apos;&#125;)</span><br><span class="line">&lt;Response [201]&gt;</span><br><span class="line">&gt;&gt;&gt; resp = requests.get(&apos;http://127.0.0.1:5000/api/users&apos;)</span><br><span class="line">&gt;&gt;&gt; resp.content</span><br><span class="line">b&apos;&#123;&quot;success&quot;: true, &quot;count&quot;: 1, &quot;items&quot;: [&#123;&quot;name&quot;: &quot;user1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;]&#125;&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>通过接口请求结果可见，接口服务运行正常。</p>
<h2 id="在单元测试用例中使用-Mock-Server"><a href="#在单元测试用例中使用-Mock-Server" class="headerlink" title="在单元测试用例中使用 Mock Server"></a>在单元测试用例中使用 Mock Server</h2><p>API接口服务（<code>Mock Server</code>）已经有了，但是如果每次运行单元测试时都要先在外部手工启动API接口服务的话，做法实在是不够优雅。</p>
<p>推荐的做法是，制作一个<code>ApiServerUnittest</code>基类，在其中添加<code>setUpClass</code>类方法，用于启动API接口服务（<code>Mock Server</code>）；添加<code>tearDownClass</code>类方法，用于停止API接口服务。由于<code>setUpClass</code>会在单元测试用例集初始化的时候执行一次，所以可以保证单元测试用例在运行的时候API服务处于可用状态；而<code>tearDownClass</code>会在单元测试用例集执行完毕后运行一次，停止API接口服务，从而避免对下一次启动产生影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tests/base.py</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> api_server</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiServerUnittest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Test case class that sets up an HTTP server which can be used within the tests</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.api_server_process = multiprocessing.Process(</span><br><span class="line">            target=api_server.app.run</span><br><span class="line">        )</span><br><span class="line">        cls.api_server_process.start()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.api_server_process.terminate()</span><br></pre></td></tr></table></figure>
<p>这里采用的是多进程的方式（<code>multiprocessing</code>），所以我们的单元测试用例可以和API接口服务（<code>Mock Server</code>）同时运行。除了多进程的方式，我看到<code>locust</code>项目采用的是<a href="https://github.com/locustio/locust/blob/master/locust/test/test_web.py" target="_blank" rel="noopener"><code>gevent.pywsgi.WSGIServer</code></a>的方式，不过由于在<code>gevent</code>中要实现异步需要先<code>monkey.patch_all()</code>，感觉比较麻烦，而且还需要引入<code>gevent</code>这么一个第三方依赖库，所以还是决定采用<code>multiprocessing</code>的方式了。至于为什么没有选择多线程模型（<code>threading</code>），是因为线程至不支持显式终止的（<code>terminate</code>），要实现终止服务会比使用<code>multiprocessing</code>更为复杂。</p>
<p>不过需要注意的是，由于启动<code>Server</code>存在一定的耗时，因此在启动完毕后必须要等待一段时间（本例中<code>0.1秒</code>就足够了），否则在执行单元测试用例时，调用的API接口可能还处于不可用状态。</p>
<p><code>ApiServerUnittest</code>基类就绪后，对于需要用到<code>Mock Server</code>的单元测试用例集，只需要继承<code>ApiServerUnittest</code>即可；其它的写法跟普通的单元测试完全一致。</p>
<p>例如，下例包含一个单元测试用例，测试“创建一个用户，该用户之前不存在”的场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tests/test_apiserver.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> .base <span class="keyword">import</span> ApiServerUnittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApiServer</span><span class="params">(ApiServerUnittest)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(TestApiServer, self).setUp()</span><br><span class="line">        self.host = <span class="string">"http://127.0.0.1:5000"</span></span><br><span class="line">        self.api_client = requests.Session()</span><br><span class="line">        self.clear_users()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(TestApiServer, self).tearDown()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_create_user_not_existed</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.clear_users()</span><br><span class="line"></span><br><span class="line">        url = <span class="string">"%s/api/users/%d"</span> % (self.host, <span class="number">1000</span>)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"user1"</span>,</span><br><span class="line">            <span class="string">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">        &#125;</span><br><span class="line">        resp = self.api_client.post(url, json=data)</span><br><span class="line"></span><br><span class="line">        self.assertEqual(<span class="number">201</span>, resp.status_code)</span><br><span class="line">        self.assertEqual(<span class="literal">True</span>, resp.json()[<span class="string">"success"</span>])</span><br></pre></td></tr></table></figure>
<h2 id="为项目添加持续集成构建检查（Travis-CI）"><a href="#为项目添加持续集成构建检查（Travis-CI）" class="headerlink" title="为项目添加持续集成构建检查（Travis CI）"></a>为项目添加持续集成构建检查（Travis CI）</h2><p>当我们的项目具有单元测试之后，我们就可以为项目添加持续集成构建检查，从而在每次提交代码至<code>GitHub</code>时都运行测试，确保我们每次提交的代码都是可正常部署及运行的。</p>
<p>要实现这个功能，推荐使用<a href="https://travis-ci.org/" target="_blank" rel="noopener"><code>Travis CI</code></a>提供的服务，该服务对于GitHub公有仓库是免费的。要完成配置，操作也很简单，基本上只有三步：</p>
<ul>
<li>在<a href="https://travis-ci.org/" target="_blank" rel="noopener"><code>Travis CI</code></a>使用GitHub账号授权登录；</li>
<li>在<a href="https://travis-ci.org/" target="_blank" rel="noopener"><code>Travis CI</code></a>的个人<code>profile</code>页面开启需要持续集成的项目；</li>
<li>在<code>Github</code>项目的根目录下添加<code>.travis.yml</code>配置文件。</li>
</ul>
<p>大多数情况下，<code>.travis.yml</code>配置文件可以很简单，例如<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>的配置就只有如下几行：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">2.7</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.3</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.4</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.5</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.6</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="bullet">-r</span> <span class="string">requirements.txt</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">python</span> <span class="bullet">-m</span> <span class="string">unittest</span> <span class="string">discover</span></span><br></pre></td></tr></table></figure>
<p>具体含义不用解释也可以很容易看懂，其中<code>install</code>中包含我们项目的依赖库安装命令，<code>script</code>中包含执行构建测试的命令。</p>
<p>配置完毕后，后续每次提交代码时，<code>GitHub</code>就会调用<code>Travis CI</code>实现构建检查；并且更赞的在于，构建检查可以同时在多个指定的<code>Python</code>版本环境中进行。</p>
<p>下图是某次提交代码时的构建结果。</p>
<p><img src="/images/travis-check-result.jpg" alt></p>
<p>另外，我们还可以在<code>GitHub</code>项目的<code>README.md</code>中添加一个<code>Status Image</code>，实时显示项目的构建状态，就像下图显示的样子。</p>
<p><img src="/images/github-readme-travis-status-image.jpg" alt></p>
<p>配置方式也是很简单，只需要先在<code>Travis CI</code>中获取到项目<code>Status Image</code>的URL地址，然后添加到<code>README.md</code>即可。</p>
<p><img src="/images/travis-status-image-url.jpg" alt></p>
<h2 id="为项目添加单元测试覆盖率检查（coveralls）"><a href="#为项目添加单元测试覆盖率检查（coveralls）" class="headerlink" title="为项目添加单元测试覆盖率检查（coveralls）"></a>为项目添加单元测试覆盖率检查（coveralls）</h2><p>对项目添加持续集成构建检查以后，就能完全保证我们提交的代码运行没问题么？</p>
<p>答案是并不能。试想，假如我们整个项目中就只有一条单元测试用例，甚至这一条单元测试用例还是个假用例，即没有调用任何代码，那么可想而知，我们的持续集成构建检查总是成功的，并没有起到检查的作用。</p>
<p>因此，这里还涉及到一个单元测试覆盖率的问题。</p>
<p>怎么理解单元测试覆盖率呢？简单地说，就是我们在执行单元测试时运行代码的行数，与项目总代码数的比值。</p>
<p>对于主流的编程语言，都存在大量的覆盖率检查工具，可以帮助我们快速统计单元测试覆盖率。在Python中，用的最多的覆盖率检查工具是<a href="https://coverage.readthedocs.io" target="_blank" rel="noopener"><code>coverage</code></a>。</p>
<p>要使用<a href="https://coverage.readthedocs.io" target="_blank" rel="noopener"><code>coverage</code></a>，需要先进行安装，采用<code>pip</code>的安装方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install coverage</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以采用如下命令执行单元测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ coverage run --<span class="built_in">source</span>=ate -m unittest discover</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是，<code>--source</code>参数的作用是指定统计的目录，如果不指定该参数，则会将所有依赖库也计算进去，但由于很多依赖库在安装时是没有包含测试代码的，因此会造成统计得到的单元测试覆盖率远低于实际的情况。在上面的命令中，就只统计了<code>ate</code>目录下的单元测试覆盖率；如果要统计当前项目的覆盖率，那么可以指定<code>--source=.</code>（即当前目录下的所有子文夹）。</p>
<p>采用上述命令执行完单元测试后，会在当前目录下生成一个统计结果文件，<code>.coverage</code>，里面包含了详细的统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat .coverage</span><br><span class="line">!coverage.py: This is a private format, don&apos;t read it directly!&#123;&quot;lines&quot;:&#123;&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/__init__.py&quot;:[1],&quot;/Users/Leo/MyProjects/</span><br><span class="line">ApiTestEngine/ate/testcase.py&quot;:[1,2,4,6,9,15,42,7,12,40,46,64,67,68,69,70,48,49,62,72,74,13,65,51,52,53,56,60,58,54,55],&quot;/Users/Leo/MyProjects/ApiTestEngi</span><br><span class="line">ne/ate/exception.py&quot;:[2,4,5,9,12,15,16,6,7],&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/utils.py&quot;:[1,2,3,4,5,7,9,11,12,14,15,18,22,25,47,51,55,65,77,90,129,1</span><br><span class="line">41,27,31,32,19,20,23,34,41,43,45,56,57,59,60,48,49,154,163,166,170,172,173,174,176,177,181,182,183,186,187,189,91,92,66,67,72,73,74,94,95,97,98,101,102,78</span><br><span class="line">,80,81,82,84,85,88,103,104,106,108,110,115,121,122,124,125,127,58,52,53,184,185,109,116,118,119,112,113,132,134,135,136,137,139,63,164,155,157,158,159,161</span><br><span class="line">,167,168,192,68,69],&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/context.py&quot;:[1,3,5,6,10,16,30,45,7,8,25,26,28,41,42,43,49,55,58,59,63,64,56,74,65,68,69,72,66</span><br><span class="line">,27,13,14,50,53,52,70],&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/main.py&quot;:[1,2,4,7,9,10,15,21,38,51,25,27,28,29,30,32,33,11,12,13,34,36,42,43,45,46,47,49],</span><br><span class="line">&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/runner.py&quot;:[1,3,4,5,8,10,15,46,68,97,135,11,12,13,35,36,38,39,41,42,44,82,63,65,66,84,86,87,88,92,93,94,95,124,12</span><br><span class="line">6,127,128,129,130,131,133,154]&#125;&#125;%</span><br></pre></td></tr></table></figure>
<p>但是，这个结果就不是给人看的。要想直观地看到统计报告，需要再执行命令<code>coverage report -m</code>，执行完后，就可以看到详细的统计数据了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ApiTestEngine git:(master) ✗ coverage report -m</span><br><span class="line">Name               Stmts   Miss  Cover   Missing</span><br><span class="line">------------------------------------------------</span><br><span class="line">ate/__init__.py        0      0   100%</span><br><span class="line">ate/context.py        35      0   100%</span><br><span class="line">ate/exception.py      11      2    82%   10, 13</span><br><span class="line">ate/main.py           34      7    79%   18-19, 54-62</span><br><span class="line">ate/runner.py         44      2    95%   89-90</span><br><span class="line">ate/testcase.py       30      0   100%</span><br><span class="line">ate/utils.py         112      8    93%   13, 29, 36-39, 178-179</span><br><span class="line">------------------------------------------------</span><br><span class="line">TOTAL                266     19    93%</span><br></pre></td></tr></table></figure>
<p>通过这个报告，可以看到项目整体的单元测试覆盖率为<code>93%</code>，并清晰地展示了每个源代码文件的具体覆盖率数据，以及没有覆盖到的代码行数。</p>
<p>那要怎么将覆盖率检查添加到我们的持续集成（Travis CI）中呢？</p>
<p>事实上，当前存在多个可选服务，可以与<code>Travis CI</code>配合使用。当前，使用得比较广泛的是<a href="https://coveralls.io" target="_blank" rel="noopener"><code>coveralls</code></a>，针对Public类型的GitHub仓库，这也是一个免费服务。</p>
<p><a href="https://coveralls.io" target="_blank" rel="noopener"><code>coveralls</code></a>的使用方式与<a href="https://travis-ci.org/" target="_blank" rel="noopener"><code>Travis CI</code></a>类似，也需要先在<a href="https://coveralls.io" target="_blank" rel="noopener"><code>coveralls</code></a>网站上采用GitHub账号授权登录，然后开启需要进行检查的GitHub仓库。而要执行的命令，也可以在<code>.travis.yml</code>配置文件中指定。</p>
<p>增加覆盖率检查后的<code>.travis.yml</code>配置文件内容如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">2.7</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.3</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.4</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.5</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">3.6</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="bullet">-r</span> <span class="string">requirements.txt</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">coverage</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">coveralls</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">coverage</span> <span class="string">run</span> <span class="bullet">--source=.</span> <span class="bullet">-m</span> <span class="string">unittest</span> <span class="string">discover</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">coveralls</span></span><br></pre></td></tr></table></figure>
<p>如上配置应该也很好理解，要使用<code>coveralls</code>的服务，需要先安装<code>coveralls</code>。在采用<code>coverage</code>执行完单元测试后，要将结果上报到<a href="https://coveralls.io" target="_blank" rel="noopener"><code>coveralls</code></a>网站，需要再执行<code>coveralls</code>命令。由于<code>coveralls</code>命令只有在测试覆盖率检查成功以后运行才有意义，因此可将其放在<code>after_success</code>部分。</p>
<p>配置完毕后，后续每次提交代码时，<code>GitHub</code>就会调用<code>Travis CI</code>实现构建检查，并同时统计得到单元测试覆盖率。</p>
<p>下图是某次提交代码时的覆盖率检查。</p>
<p><img src="/images/coveralls-result.jpg" alt></p>
<p>另外，我们在<code>GitHub</code>项目的<code>README.md</code>中也同样可以添加一个<code>Status Image</code>，实时显示项目的单元测试覆盖率。</p>
<p><img src="/images/github-coveralls-badge.jpg" alt></p>
<p>配置方式也跟之前类似，在<a href="https://coveralls.io" target="_blank" rel="noopener"><code>coveralls</code></a>中获取到项目<code>Status Image</code>的URL地址，然后添加到<code>README.md</code>即可。</p>
<p><img src="/images/coveralls-image-url.jpg" alt></p>
<p>最后需要说明的是，项目的单元测试覆盖率只能起到参考作用，没有被单元测试覆盖到的代码我们不能说它肯定有问题，100%覆盖率的代码也并不能保证它肯定没有问题。归根结底，这还是要依赖于单元测试的策略实现，因此我们在写单元测试的时候也要尽可能多地覆盖到各种逻辑路径，以及兼顾到各种异常情况。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>通过本文中的工作，我们就对项目搭建好了测试框架，并实现了持续集成构建检查机制。从下一篇开始，我们就将开始逐步实现接口自动化测试框架的核心功能特性了。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/" target="_blank" rel="noopener">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/huzi.jpg" alt="solomiss">
            
              <p class="site-author-name" itemprop="name">solomiss</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/solomiss" title="GitHub &rarr; https://github.com/solomiss" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mickqi1985@163.com" title="E-Mail &rarr; mailto:mickqi1985@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      

      
      <!--div id="music163player">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=460043703&auto=0&height=66">
        </iframe>

      </div-->
      <div id="music163player">
      <audio controls="controls" playsinline webkit-playsinline height="100" width="100%" autoplay loop hidden="true">  
      <source src="https://link.hhtjim.com/163/460043703.mp3" type="audio/mpeg">  
      </audio>
      </div>

    </div>
  </aside>
  
    <div id="sidebar-dimmer">

    </div>
  



        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">solomiss</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
